<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Three Rivers Rumble - Competition Timer</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
    .tabular-nums { font-variant-numeric: tabular-nums; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    input[type="range"] { -webkit-appearance: none; background: rgba(255,255,255,0.2); border-radius: 9999px; height: 8px; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: white; cursor: pointer; }
    input[type="text"], input[type="number"] { outline: none; }
    button { cursor: pointer; transition: transform 0.15s; }
    button:hover { transform: scale(1.02); }
    button:active { transform: scale(0.98); }
    .kbd { display: inline-block; padding: 0.2rem 0.5rem; background: rgba(255,255,255,0.2); border-radius: 0.25rem; font-family: monospace; font-size: 0.8rem; margin: 0 0.1rem; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // QR Code Generator (simplified)
    function generateQRCode(text) {
      const size = 29;
      const matrix = Array(size).fill(null).map(() => Array(size).fill(null));
      const reserved = Array(size).fill(null).map(() => Array(size).fill(false));
      
      function addFinderPattern(x, y) {
        for (let dy = -1; dy <= 7; dy++) {
          for (let dx = -1; dx <= 7; dx++) {
            const px = x + dx, py = y + dy;
            if (px < 0 || py < 0 || px >= size || py >= size) continue;
            reserved[py][px] = true;
            if (dx === -1 || dx === 7 || dy === -1 || dy === 7) matrix[py][px] = false;
            else if ((dx === 0 || dx === 6) || (dy === 0 || dy === 6)) matrix[py][px] = true;
            else if (dx >= 2 && dx <= 4 && dy >= 2 && dy <= 4) matrix[py][px] = true;
            else matrix[py][px] = false;
          }
        }
      }
      addFinderPattern(0, 0); addFinderPattern(size - 7, 0); addFinderPattern(0, size - 7);
      for (let i = 8; i < size - 8; i++) { reserved[6][i] = reserved[i][6] = true; matrix[6][i] = matrix[i][6] = i % 2 === 0; }
      reserved[size - 8][8] = true; matrix[size - 8][8] = true;
      for (let i = 0; i < 9; i++) { reserved[8][i] = reserved[i][8] = true; }
      for (let i = 0; i < 8; i++) { reserved[8][size - 1 - i] = reserved[size - 1 - i][8] = true; }
      const bytes = new TextEncoder().encode(text);
      let bits = '0100' + bytes.length.toString(2).padStart(8, '0');
      bytes.forEach(b => bits += b.toString(2).padStart(8, '0'));
      bits += '0000';
      while (bits.length % 8 !== 0) bits += '0';
      const capacity = 70 * 8;
      let padIndex = 0;
      const padBytes = ['11101100', '00010001'];
      while (bits.length < capacity) bits += padBytes[padIndex++ % 2];
      let bitIndex = 0, upward = true;
      for (let col = size - 1; col >= 1; col -= 2) {
        if (col === 6) col = 5;
        for (let row = 0; row < size; row++) {
          const actualRow = upward ? size - 1 - row : row;
          for (let c = 0; c < 2; c++) {
            const x = col - c, y = actualRow;
            if (!reserved[y][x] && bitIndex < bits.length) matrix[y][x] = bits[bitIndex++] === '1';
          }
        }
        upward = !upward;
      }
      const formatBits = '111011111000100';
      for (let i = 0; i < 6; i++) { matrix[8][i] = formatBits[i] === '1'; matrix[i][8] = formatBits[14 - i] === '1'; }
      matrix[8][7] = formatBits[6] === '1'; matrix[8][8] = formatBits[7] === '1'; matrix[7][8] = formatBits[8] === '1';
      for (let i = 0; i < 7; i++) { matrix[8][size - 1 - i] = formatBits[14 - i] === '1'; matrix[size - 1 - i][8] = formatBits[i] === '1'; }
      matrix[8][size - 8] = formatBits[7] === '1';
      for (let y = 0; y < size; y++) for (let x = 0; x < size; x++) if (!reserved[y][x] && (x + y) % 2 === 0) matrix[y][x] = !matrix[y][x];
      return matrix;
    }

    const QRCodeCanvas = ({ value, size = 200 }) => {
      const canvasRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current || !value) return;
        const ctx = canvasRef.current.getContext('2d');
        const qr = generateQRCode(value);
        const cellSize = size / qr.length;
        canvasRef.current.width = size; canvasRef.current.height = size;
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = '#000000';
        qr.forEach((row, y) => row.forEach((cell, x) => {
          if (cell) ctx.fillRect(Math.floor(x * cellSize), Math.floor(y * cellSize), Math.ceil(cellSize), Math.ceil(cellSize));
        }));
      }, [value, size]);
      return <canvas ref={canvasRef} style={{ width: size, height: size }} />;
    };

    // Audio Hook
    const useAudio = () => {
      const audioCtxRef = useRef(null);
      const getCtx = useCallback(() => {
        if (!audioCtxRef.current || audioCtxRef.current.state === 'closed')
          audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
        return audioCtxRef.current;
      }, []);
      
      const playBeep = useCallback((freq = 880, dur = 0.15, type = 'sine', vol = 0.5) => {
        try {
          const ctx = getCtx();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain); gain.connect(ctx.destination);
          osc.frequency.value = freq; osc.type = type;
          gain.gain.setValueAtTime(vol, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + dur);
        } catch (e) {}
      }, [getCtx]);
      
      return {
        playCountdownBeep: useCallback(() => playBeep(1000, 0.15, 'sine', 0.6), [playBeep]),
        playEndBeep: useCallback(() => playBeep(1000, 0.6, 'sine', 0.6), [playBeep]),
        playOneMinuteBeep: useCallback(() => { playBeep(880, 0.15); setTimeout(() => playBeep(880, 0.15), 200); }, [playBeep]),
        playAlertBeep: useCallback(() => playBeep(550, 0.3, 'sine', 0.5), [playBeep]),
        getCtx
      };
    };

    // Voice Announcements Hook
    const useVoice = (enabled) => {
      const speak = useCallback((text) => {
        if (!enabled || !window.speechSynthesis) return;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1;
        utterance.volume = 1;
        window.speechSynthesis.speak(utterance);
      }, [enabled]);
      return { speak };
    };

    // Wake Lock Hook
    const useWakeLock = () => {
      const wakeLockRef = useRef(null);
      const [isLocked, setIsLocked] = useState(false);
      
      const requestWakeLock = useCallback(async () => {
        try {
          if ('wakeLock' in navigator) {
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            setIsLocked(true);
            wakeLockRef.current.addEventListener('release', () => setIsLocked(false));
          }
        } catch (e) { console.log('Wake lock failed:', e); }
      }, []);
      
      const releaseWakeLock = useCallback(() => {
        if (wakeLockRef.current) {
          wakeLockRef.current.release();
          wakeLockRef.current = null;
          setIsLocked(false);
        }
      }, []);
      
      useEffect(() => {
        const handleVisibility = () => {
          if (document.visibilityState === 'visible' && isLocked) requestWakeLock();
        };
        document.addEventListener('visibilitychange', handleVisibility);
        return () => document.removeEventListener('visibilitychange', handleVisibility);
      }, [isLocked, requestWakeLock]);
      
      return { isLocked, requestWakeLock, releaseWakeLock };
    };

    // Icons
    const Icons = {
      Play: () => <svg width="32" height="32" viewBox="0 0 24 24" fill="white"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
      Pause: () => <svg width="32" height="32" viewBox="0 0 24 24" fill="white"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
      Reset: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
      Skip: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="5 4 15 12 5 20 5 4" fill="white"/><line x1="19" y1="5" x2="19" y2="19"/></svg>,
      Settings: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>,
      QR: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="3" height="3"/><rect x="18" y="14" width="3" height="3"/><rect x="14" y="18" width="3" height="3"/><rect x="18" y="18" width="3" height="3"/></svg>,
      Volume: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>,
      Mute: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.5)" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>,
      Fullscreen: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>,
      Sync: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>,
      Users: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
      Check: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
      Copy: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Link: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
      Keyboard: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M6 12h.01M10 12h.01M14 12h.01M18 12h.01M8 16h8"/></svg>,
      Clock: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>,
      ChevronUp: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M18 15l-6-6-6 6"/></svg>,
      ChevronDown: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M6 9l6 6 6-6"/></svg>,
      Plus: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
      Minus: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>,
      Mic: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></svg>,
      MicOff: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.5)" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V5a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .74-.11 1.45-.32 2.12"/><line x1="12" y1="19" x2="12" y2="22"/></svg>,
      Moon: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>,
    };

    // Main Component
    function ClimbingTimer() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlRoomCode = urlParams.get('room');
      const isDisplayMode = urlParams.get('display') === '1';
      
      // State
      const [roomCode, setRoomCode] = useState(urlRoomCode || '');
      const [isHost, setIsHost] = useState(!urlRoomCode);
      const [joinRoomInput, setJoinRoomInput] = useState('');
      
      const [settings, setSettings] = useState({
        climbDuration: 240,
        transitionDuration: 30,
        prepDuration: 0,
        warningTime: 60,
        enableAutoTransition: true,
        voiceAnnouncements: false,
        showClock: true,
      });
      
      const [timerState, setTimerState] = useState({
        isRunning: false,
        phase: 'idle',
        timeRemaining: 240,
        round: 1,
        phaseStartTime: null,
      });
      
      const [climberInfo, setClimberInfo] = useState({ name: '', number: '' });
      const [climberQueue, setClimberQueue] = useState([]);
      const [attempts, setAttempts] = useState(0);
      const [tops, setTops] = useState(0);
      const [showSettings, setShowSettings] = useState(false);
      const [showQR, setShowQR] = useState(false);
      const [showJoinModal, setShowJoinModal] = useState(false);
      const [showShortcuts, setShowShortcuts] = useState(false);
      const [showQueue, setShowQueue] = useState(false);
      const [soundEnabled, setSoundEnabled] = useState(!isDisplayMode);
      const [copied, setCopied] = useState(false);
      const [connected, setConnected] = useState(false);
      const [peerCount, setPeerCount] = useState(0);
      const [peerError, setPeerError] = useState(null);
      const [currentTime, setCurrentTime] = useState(new Date());
      
      const containerRef = useRef(null);
      const lastSecondRef = useRef(null);
      const phaseRef = useRef(timerState.phase);
      const peerRef = useRef(null);
      const connectionsRef = useRef([]);
      const timerStateRef = useRef(timerState);
      const settingsRef = useRef(settings);
      const climberInfoRef = useRef(climberInfo);
      const attemptsRef = useRef(attempts);
      const topsRef = useRef(tops);
      
      const { playCountdownBeep, playEndBeep, playOneMinuteBeep, playAlertBeep, getCtx } = useAudio();
      const { speak } = useVoice(settings.voiceAnnouncements && soundEnabled);
      const { isLocked, requestWakeLock, releaseWakeLock } = useWakeLock();
      
      // Keep refs updated
      useEffect(() => { timerStateRef.current = timerState; }, [timerState]);
      useEffect(() => { settingsRef.current = settings; }, [settings]);
      useEffect(() => { climberInfoRef.current = climberInfo; }, [climberInfo]);
      useEffect(() => { phaseRef.current = timerState.phase; }, [timerState.phase]);
      useEffect(() => { attemptsRef.current = attempts; }, [attempts]);
      useEffect(() => { topsRef.current = tops; }, [tops]);
      
      // Clock update
      useEffect(() => {
        const interval = setInterval(() => setCurrentTime(new Date()), 1000);
        return () => clearInterval(interval);
      }, []);
      
      // Broadcast state
      const broadcastState = useCallback(() => {
        const data = { 
          type: 'state', 
          timerState: timerStateRef.current, 
          settings: settingsRef.current, 
          climberInfo: climberInfoRef.current,
          attempts: attemptsRef.current,
          tops: topsRef.current
        };
        connectionsRef.current.forEach(conn => {
          if (conn?.open) try { conn.send(data); } catch (e) {}
        });
      }, []);
      
      const handleReceivedState = useCallback((data) => {
        if (data.type === 'state') {
          setTimerState(data.timerState);
          setSettings(data.settings);
          setClimberInfo(data.climberInfo || { name: '', number: '' });
          if (data.attempts !== undefined) setAttempts(data.attempts);
          if (data.tops !== undefined) setTops(data.tops);
        }
      }, []);
      
      // PeerJS setup
      useEffect(() => {
        if (!roomCode) return;
        const peerId = isHost ? `trr-${roomCode}` : `trr-${roomCode}-${Date.now()}`;
        const peer = new Peer(peerId, { debug: 0 });
        peerRef.current = peer;
        
        peer.on('open', () => {
          setConnected(true);
          setPeerError(null);
          if (!isHost) {
            const conn = peer.connect(`trr-${roomCode}`, { reliable: true });
            conn.on('open', () => {
              connectionsRef.current = [conn];
              setPeerCount(1);
              conn.send({ type: 'requestState' });
            });
            conn.on('data', handleReceivedState);
            conn.on('close', () => { setPeerCount(0); setPeerError('Disconnected'); });
          }
        });
        
        if (isHost) {
          peer.on('connection', (conn) => {
            conn.on('open', () => {
              connectionsRef.current.push(conn);
              setPeerCount(connectionsRef.current.length);
              conn.send({ type: 'state', timerState: timerStateRef.current, settings: settingsRef.current, climberInfo: climberInfoRef.current, attempts: attemptsRef.current, tops: topsRef.current });
            });
            conn.on('data', (data) => {
              if (data.type === 'requestState') {
                conn.send({ type: 'state', timerState: timerStateRef.current, settings: settingsRef.current, climberInfo: climberInfoRef.current, attempts: attemptsRef.current, tops: topsRef.current });
              }
            });
            conn.on('close', () => {
              connectionsRef.current = connectionsRef.current.filter(c => c !== conn);
              setPeerCount(connectionsRef.current.length);
            });
          });
        }
        
        peer.on('error', (err) => {
          if (err.type === 'unavailable-id') setPeerError('Room exists');
          else if (err.type === 'peer-unavailable') setPeerError('Room not found');
          else setPeerError('Connection error');
        });
        
        return () => {
          connectionsRef.current.forEach(c => { try { c.close(); } catch(e) {} });
          connectionsRef.current = [];
          peer?.destroy();
        };
      }, [roomCode, isHost, handleReceivedState]);
      
      // Broadcast on state change
      useEffect(() => {
        if (isHost && connected && roomCode) broadcastState();
      }, [timerState, settings, climberInfo, attempts, tops, isHost, connected, roomCode, broadcastState]);
      
      // Continuous sync while running
      useEffect(() => {
        if (!isHost || !connected || !timerState.isRunning) return;
        const interval = setInterval(broadcastState, 250);
        return () => clearInterval(interval);
      }, [isHost, connected, timerState.isRunning, broadcastState]);
      
      const formatTime = (seconds) => `${Math.floor(Math.abs(seconds) / 60)}:${(Math.abs(seconds) % 60).toString().padStart(2, '0')}`;
      
      const getPhaseDuration = (phase) => {
        if (phase === 'prep') return settings.prepDuration;
        if (phase === 'climb') return settings.climbDuration;
        if (phase === 'transition') return settings.transitionDuration;
        return settings.climbDuration;
      };
      
      // Timer loop
      useEffect(() => {
        if (!timerState.isRunning || !timerState.phaseStartTime) return;
        
        const interval = setInterval(() => {
          const now = Date.now();
          const duration = getPhaseDuration(timerState.phase);
          const elapsed = Math.floor((now - timerState.phaseStartTime) / 1000);
          const remaining = Math.max(0, duration - elapsed);
          
          setTimerState(prev => ({ ...prev, timeRemaining: remaining }));
          
          // Sound & voice
          if (soundEnabled && remaining !== lastSecondRef.current && lastSecondRef.current !== null) {
            const prevSec = lastSecondRef.current;
            if (remaining === 3 && prevSec > 3) { playCountdownBeep(); speak('3'); }
            else if (remaining === 2 && prevSec > 2) { playCountdownBeep(); speak('2'); }
            else if (remaining === 1 && prevSec > 1) { playCountdownBeep(); speak('1'); }
            else if (remaining === 0 && prevSec > 0) { 
              playEndBeep(); 
              if (phaseRef.current === 'climb') speak('Time');
              else if (phaseRef.current === 'transition' || phaseRef.current === 'prep') speak('Climb');
            }
            else if (phaseRef.current === 'climb' && remaining === settings.warningTime && prevSec > settings.warningTime) {
              playOneMinuteBeep();
              speak('One minute remaining');
            }
          }
          lastSecondRef.current = remaining;
          
          // Phase transitions
          if ((isHost || !roomCode) && remaining === 0 && elapsed >= duration && settings.enableAutoTransition) {
            const t = timerState.phaseStartTime + duration * 1000;
            setTimerState(prev => {
              if (prev.phase === 'prep') return { ...prev, phase: 'climb', phaseStartTime: t, timeRemaining: settings.climbDuration };
              if (prev.phase === 'climb') {
                if (settings.transitionDuration === 0) {
                  const np = settings.prepDuration > 0 ? 'prep' : 'climb';
                  return { ...prev, round: prev.round + 1, phase: np, phaseStartTime: t, timeRemaining: settings.prepDuration || settings.climbDuration };
                }
                return { ...prev, phase: 'transition', phaseStartTime: t, timeRemaining: settings.transitionDuration };
              }
              if (prev.phase === 'transition') {
                const np = settings.prepDuration > 0 ? 'prep' : 'climb';
                return { ...prev, phase: np, round: prev.round + 1, phaseStartTime: t, timeRemaining: settings.prepDuration || settings.climbDuration };
              }
              return prev;
            });
          }
        }, 50);
        return () => clearInterval(interval);
      }, [timerState.isRunning, timerState.phaseStartTime, timerState.phase, settings, soundEnabled, isHost, roomCode, speak]);
      
      // Wake lock on start
      useEffect(() => {
        if (timerState.isRunning && !isLocked) requestWakeLock();
        else if (!timerState.isRunning && timerState.phase === 'idle' && isLocked) releaseWakeLock();
      }, [timerState.isRunning, timerState.phase, isLocked, requestWakeLock, releaseWakeLock]);
      
      const handleStart = () => {
        getCtx();
        const now = Date.now();
        const startPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
        const startDuration = settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration;
        setTimerState(prev => ({
          ...prev, isRunning: true,
          phase: prev.phase === 'idle' ? startPhase : prev.phase,
          phaseStartTime: now,
          timeRemaining: prev.phase === 'idle' ? startDuration : prev.timeRemaining,
        }));
        if (soundEnabled && timerState.phase === 'idle') {
          playEndBeep();
          speak(settings.prepDuration > 0 ? 'Observation' : 'Climb');
        }
      };
      
      const handlePause = () => setTimerState(prev => ({ ...prev, isRunning: false }));
      
      const handleReset = () => {
        setTimerState({ isRunning: false, phase: 'idle', timeRemaining: settings.climbDuration, round: 1, phaseStartTime: null });
        lastSecondRef.current = null;
        setAttempts(0);
        setTops(0);
      };
      
      const handleSkip = () => {
        const now = Date.now();
        setTimerState(prev => {
          if (prev.phase === 'prep') return { ...prev, phase: 'climb', phaseStartTime: now, timeRemaining: settings.climbDuration };
          if (prev.phase === 'climb') {
            if (settings.transitionDuration === 0) {
              const np = settings.prepDuration > 0 ? 'prep' : 'climb';
              return { ...prev, round: prev.round + 1, phase: np, phaseStartTime: now, timeRemaining: settings.prepDuration || settings.climbDuration };
            }
            return { ...prev, phase: 'transition', phaseStartTime: now, timeRemaining: settings.transitionDuration };
          }
          const np = settings.prepDuration > 0 ? 'prep' : 'climb';
          return { ...prev, phase: np, round: prev.round + 1, phaseStartTime: now, timeRemaining: settings.prepDuration || settings.climbDuration };
        });
      };
      
      const handleAddTime = (seconds) => {
        setTimerState(prev => ({
          ...prev,
          phaseStartTime: prev.phaseStartTime ? prev.phaseStartTime + (seconds * 1000) : prev.phaseStartTime,
          timeRemaining: Math.max(0, prev.timeRemaining + seconds),
        }));
      };
      
      const nextClimber = () => {
        if (climberQueue.length > 0) {
          const [next, ...rest] = climberQueue;
          setClimberInfo({ name: next.name, number: next.number });
          setClimberQueue(rest);
          setAttempts(0);
          setTops(0);
        }
      };
      
      const toggleFullscreen = () => {
        if (!document.fullscreenElement) containerRef.current?.requestFullscreen();
        else document.exitFullscreen();
      };
      
      const createRoom = () => { setRoomCode(Math.random().toString(36).substring(2, 8).toUpperCase()); setIsHost(true); };
      const joinRoom = () => { if (joinRoomInput.trim()) { setRoomCode(joinRoomInput.trim().toUpperCase()); setIsHost(false); setShowJoinModal(false); } };
      const copyToClipboard = (text) => { navigator.clipboard.writeText(text); setCopied(true); setTimeout(() => setCopied(false), 2000); };
      const getSyncUrl = () => `${window.location.origin}${window.location.pathname}?room=${roomCode}&display=1`;
      
      // Keyboard shortcuts
      useEffect(() => {
        const canControl = isHost || !roomCode;
        if (!canControl) return;
        
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              timerState.isRunning ? handlePause() : handleStart();
              break;
            case 'KeyS':
              if (timerState.phase !== 'idle') handleSkip();
              break;
            case 'KeyR':
              handleReset();
              break;
            case 'KeyM':
              getCtx();
              setSoundEnabled(s => !s);
              break;
            case 'KeyF':
              toggleFullscreen();
              break;
            case 'KeyN':
              nextClimber();
              break;
            case 'KeyA':
              setAttempts(a => a + 1);
              break;
            case 'KeyT':
              setTops(t => t + 1);
              break;
            case 'ArrowUp':
              e.preventDefault();
              if (timerState.phase !== 'idle') handleAddTime(5);
              break;
            case 'ArrowDown':
              e.preventDefault();
              if (timerState.phase !== 'idle') handleAddTime(-5);
              break;
            case 'Slash':
              if (e.shiftKey) setShowShortcuts(s => !s);
              break;
            case 'Escape':
              setShowSettings(false);
              setShowQR(false);
              setShowJoinModal(false);
              setShowShortcuts(false);
              setShowQueue(false);
              break;
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [timerState.isRunning, timerState.phase, isHost, roomCode, climberQueue]);
      
      const getPhaseLabel = () => {
        switch (timerState.phase) {
          case 'prep': return 'â³ OBSERVATION';
          case 'climb': return 'ðŸ§— CLIMB';
          case 'transition': return 'ðŸ”„ TRANSITION';
          default: return 'READY';
        }
      };
      
      const getPhaseColor = () => {
        switch (timerState.phase) {
          case 'prep': return 'linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%)';
          case 'climb': return 'linear-gradient(135deg, #059669 0%, #064e3b 100%)';
          case 'transition': return 'linear-gradient(135deg, #f59e0b 0%, #c2410c 100%)';
          default: return 'linear-gradient(135deg, #334155 0%, #0f172a 100%)';
        }
      };
      
      const getTimeColor = () => {
        if (timerState.timeRemaining <= 3 && timerState.timeRemaining > 0) return '#f87171';
        if (timerState.timeRemaining <= settings.warningTime && timerState.phase === 'climb') return '#fde047';
        return 'white';
      };
      
      const progressPct = timerState.phase !== 'idle' ? ((getPhaseDuration(timerState.phase) - timerState.timeRemaining) / getPhaseDuration(timerState.phase)) * 100 : 0;
      const canControl = isHost || !roomCode;

      return (
        <div ref={containerRef} style={{ minHeight: '100vh', background: getPhaseColor(), display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '1rem', transition: 'background 0.5s', position: 'relative' }}>
          
          {/* Progress Bar */}
          {timerState.phase !== 'idle' && (
            <div style={{ position: 'absolute', top: 0, left: 0, right: 0, height: '6px', background: 'rgba(0,0,0,0.3)' }}>
              <div style={{ height: '100%', background: 'rgba(255,255,255,0.8)', width: `${progressPct}%`, transition: 'width 0.1s' }} />
            </div>
          )}
          
          {/* Header */}
          <div style={{ position: 'absolute', top: '1rem', left: '1rem', right: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
              {/* Clock */}
              {settings.showClock && (
                <span style={{ color: 'rgba(255,255,255,0.5)', fontSize: '0.875rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                  <Icons.Clock /> {currentTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
              )}
              <span style={{ color: 'rgba(255,255,255,0.9)', fontSize: '1.5rem', fontWeight: 'bold' }}>Round {timerState.round}</span>
              {climberInfo.name && <span style={{ color: 'rgba(255,255,255,0.7)', fontSize: '1.125rem' }}>{climberInfo.number && `#${climberInfo.number} `}{climberInfo.name}</span>}
              
              {/* Attempts & Tops counter */}
              {(attempts > 0 || tops > 0 || timerState.phase === 'climb') && canControl && (
                <div style={{ display: 'flex', gap: '1rem', marginTop: '0.25rem' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    <span style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem' }}>ATT:</span>
                    <button onClick={() => setAttempts(a => Math.max(0, a - 1))} style={{ padding: '0.25rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.25rem', color: 'white' }}><Icons.Minus /></button>
                    <span style={{ color: 'white', fontSize: '1.25rem', fontWeight: 'bold', minWidth: '1.5rem', textAlign: 'center' }}>{attempts}</span>
                    <button onClick={() => setAttempts(a => a + 1)} style={{ padding: '0.25rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.25rem', color: 'white' }}><Icons.Plus /></button>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    <span style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem' }}>TOP:</span>
                    <button onClick={() => setTops(t => Math.max(0, t - 1))} style={{ padding: '0.25rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.25rem', color: 'white' }}><Icons.Minus /></button>
                    <span style={{ color: 'white', fontSize: '1.25rem', fontWeight: 'bold', minWidth: '1.5rem', textAlign: 'center' }}>{tops}</span>
                    <button onClick={() => setTops(t => t + 1)} style={{ padding: '0.25rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.25rem', color: 'white' }}><Icons.Plus /></button>
                  </div>
                </div>
              )}
              
              {/* Sync status */}
              {roomCode && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flexWrap: 'wrap' }}>
                  <span style={{ padding: '0.25rem 0.5rem', background: connected ? 'rgba(34,197,94,0.3)' : 'rgba(239,68,68,0.3)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                    <Icons.Sync /> {connected ? (isHost ? 'Hosting' : 'Synced') : 'Connecting...'}
                  </span>
                  {isHost && peerCount > 0 && <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}><Icons.Users /> {peerCount}</span>}
                  <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', fontFamily: 'monospace' }}>{roomCode}</span>
                </div>
              )}
              {peerError && <span style={{ color: '#f87171', fontSize: '0.75rem' }}>{peerError}</span>}
            </div>
            
            {/* Controls */}
            <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', justifyContent: 'flex-end' }}>
              <button onClick={() => { getCtx(); setSoundEnabled(!soundEnabled); }} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                {soundEnabled ? <Icons.Volume /> : <Icons.Mute />}
              </button>
              {canControl && (
                <>
                  <button onClick={() => setSettings(s => ({ ...s, voiceAnnouncements: !s.voiceAnnouncements }))} style={{ padding: '0.75rem', borderRadius: '9999px', background: settings.voiceAnnouncements ? 'rgba(34,197,94,0.3)' : 'rgba(255,255,255,0.1)', border: 'none' }}>
                    {settings.voiceAnnouncements ? <Icons.Mic /> : <Icons.MicOff />}
                  </button>
                  <button onClick={() => setShowShortcuts(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                    <Icons.Keyboard />
                  </button>
                </>
              )}
              <button onClick={toggleFullscreen} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                <Icons.Fullscreen />
              </button>
              {canControl && (
                <>
                  <button onClick={() => setShowSettings(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                    <Icons.Settings />
                  </button>
                  <button onClick={() => setShowQR(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                    <Icons.QR />
                  </button>
                </>
              )}
            </div>
          </div>

          {/* Main Display */}
          <div style={{ fontSize: 'clamp(1.5rem, 5vw, 2.5rem)', fontWeight: 'bold', textTransform: 'uppercase', letterSpacing: '0.1em', marginBottom: '0.5rem', color: 'rgba(255,255,255,0.95)' }}>{getPhaseLabel()}</div>

          <div className="tabular-nums" style={{ fontSize: 'clamp(6rem, 28vw, 16rem)', fontFamily: 'ui-monospace, monospace', fontWeight: 'bold', color: getTimeColor(), lineHeight: 1, animation: timerState.timeRemaining <= 3 && timerState.timeRemaining > 0 && timerState.phase !== 'idle' ? 'pulse 1s infinite' : 'none' }}>
            {formatTime(timerState.timeRemaining)}
          </div>

          <div style={{ marginTop: '0.5rem', color: 'rgba(255,255,255,0.6)', fontSize: '1.125rem', textAlign: 'center' }}>
            {timerState.phase === 'idle' && `${settings.prepDuration > 0 ? formatTime(settings.prepDuration) + ' obs â€¢ ' : ''}${formatTime(settings.climbDuration)} climb${settings.transitionDuration > 0 ? ' â€¢ ' + formatTime(settings.transitionDuration) + ' transition' : ''}`}
            {timerState.phase === 'prep' && 'Climber may observe the wall'}
            {timerState.phase === 'climb' && (settings.transitionDuration > 0 ? 'Transition begins when timer ends' : 'Next round begins when timer ends')}
            {timerState.phase === 'transition' && `Round ${timerState.round + 1} starts when timer ends`}
          </div>

          {/* Controls */}
          {canControl && (
            <div style={{ marginTop: '2rem', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1rem' }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '0.75rem' }}>
                {!timerState.isRunning ? (
                  <button onClick={handleStart} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Play /> {timerState.phase === 'idle' ? 'Start' : 'Resume'}
                  </button>
                ) : (
                  <button onClick={handlePause} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Pause /> Pause
                  </button>
                )}
                
                {timerState.phase !== 'idle' && (
                  <>
                    <button onClick={handleSkip} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}>
                      <Icons.Skip /> Skip
                    </button>
                    <button onClick={handleReset} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}>
                      <Icons.Reset /> Reset
                    </button>
                  </>
                )}
              </div>
              
              {/* Time adjustment */}
              {timerState.phase !== 'idle' && (
                <div style={{ display: 'flex', gap: '0.5rem' }}>
                  {[-10, -5, 5, 10].map(s => (
                    <button key={s} onClick={() => handleAddTime(s)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>
                      {s > 0 ? '+' : ''}{s}s
                    </button>
                  ))}
                </div>
              )}
              
              {/* Next climber button */}
              {climberQueue.length > 0 && (
                <button onClick={nextClimber} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'white', fontSize: '0.875rem' }}>
                  Next: {climberQueue[0]?.name || 'Unknown'} â†’
                </button>
              )}
            </div>
          )}

          {/* Room creation */}
          {!roomCode && timerState.phase === 'idle' && canControl && (
            <div style={{ marginTop: '2rem', display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
              <button onClick={createRoom} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'white', fontSize: '0.875rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <Icons.Link /> Create Sync Room
              </button>
              <button onClick={() => setShowJoinModal(true)} style={{ padding: '0.75rem 1.5rem', background: 'transparent', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'rgba(255,255,255,0.8)', fontSize: '0.875rem' }}>
                Join Existing Room
              </button>
            </div>
          )}

          {/* Settings Modal */}
          {showSettings && (
            <div onClick={() => setShowSettings(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '32rem', maxHeight: '90vh', overflowY: 'auto' }}>
                <h2 style={{ fontSize: '1.75rem', fontWeight: 'bold', color: 'white', marginBottom: '1.5rem' }}>Settings</h2>
                
                {/* Climber Info */}
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(255,255,255,0.05)', borderRadius: '0.75rem' }}>
                  <h3 style={{ color: 'rgba(255,255,255,0.8)', marginBottom: '0.75rem', fontSize: '1rem' }}>Current Climber</h3>
                  <div style={{ display: 'flex', gap: '0.75rem' }}>
                    <input type="text" placeholder="#" value={climberInfo.number} onChange={e => setClimberInfo(p => ({ ...p, number: e.target.value }))}
                      style={{ width: '60px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                    <input type="text" placeholder="Name" value={climberInfo.name} onChange={e => setClimberInfo(p => ({ ...p, name: e.target.value }))}
                      style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                  </div>
                </div>
                
                {/* Climber Queue */}
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(255,255,255,0.05)', borderRadius: '0.75rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                    <h3 style={{ color: 'rgba(255,255,255,0.8)', fontSize: '1rem' }}>Climber Queue ({climberQueue.length})</h3>
                    <button onClick={() => setClimberQueue([...climberQueue, { name: '', number: '' }])} style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.25rem', color: 'white', fontSize: '0.8rem' }}>+ Add</button>
                  </div>
                  {climberQueue.map((c, i) => (
                    <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.5rem' }}>
                      <input type="text" placeholder="#" value={c.number} onChange={e => { const q = [...climberQueue]; q[i].number = e.target.value; setClimberQueue(q); }}
                        style={{ width: '50px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.5rem', color: 'white', fontSize: '0.875rem' }} />
                      <input type="text" placeholder="Name" value={c.name} onChange={e => { const q = [...climberQueue]; q[i].name = e.target.value; setClimberQueue(q); }}
                        style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.5rem', color: 'white', fontSize: '0.875rem' }} />
                      <button onClick={() => setClimberQueue(climberQueue.filter((_, j) => j !== i))} style={{ padding: '0.5rem', background: 'rgba(239,68,68,0.3)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>Ã—</button>
                    </div>
                  ))}
                </div>
                
                {/* Time Settings */}
                {[
                  { label: 'Observation Time', key: 'prepDuration', min: 0, max: 120, step: 5, presets: [0, 30, 45, 60], color: '#7c3aed' },
                  { label: 'Climb Duration', key: 'climbDuration', min: 60, max: 600, step: 30, presets: [180, 240, 300, 360], color: '#059669' },
                  { label: 'Transition Duration', key: 'transitionDuration', min: 0, max: 120, step: 5, presets: [0, 15, 30, 45], color: '#d97706' },
                ].map(({ label, key, min, max, step, presets, color }) => (
                  <div key={key} style={{ marginBottom: '1.5rem' }}>
                    <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>{label}</label>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                      <input type="range" min={min} max={max} step={step} value={settings[key]}
                        onChange={(e) => setSettings(s => ({ ...s, [key]: parseInt(e.target.value) }))} style={{ flex: 1 }} />
                      <span style={{ color: 'white', fontFamily: 'monospace', fontSize: '1.25rem', width: '4rem', textAlign: 'right' }}>{settings[key] === 0 ? 'None' : formatTime(settings[key])}</span>
                    </div>
                    <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                      {presets.map(t => (
                        <button key={t} onClick={() => setSettings(s => ({ ...s, [key]: t }))}
                          style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings[key] === t ? color : 'rgba(255,255,255,0.1)', color: 'white' }}>
                          {t === 0 ? 'None' : formatTime(t)}
                        </button>
                      ))}
                    </div>
                  </div>
                ))}
                
                {/* Warning Time */}
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Warning Beep At</label>
                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                    {[30, 60, 90, 120].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, warningTime: t }))}
                        style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.warningTime === t ? '#3b82f6' : 'rgba(255,255,255,0.1)', color: 'white' }}>
                        {formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                {/* Toggles */}
                {[
                  { label: 'Auto-advance phases', key: 'enableAutoTransition' },
                  { label: 'Show clock', key: 'showClock' },
                  { label: 'Voice announcements', key: 'voiceAnnouncements' },
                ].map(({ label, key }) => (
                  <div key={key} style={{ marginBottom: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                    <label style={{ color: 'rgba(255,255,255,0.8)' }}>{label}</label>
                    <button onClick={() => setSettings(s => ({ ...s, [key]: !s[key] }))}
                      style={{ width: '3rem', height: '1.75rem', borderRadius: '9999px', border: 'none', background: settings[key] ? '#059669' : 'rgba(255,255,255,0.2)', position: 'relative' }}>
                      <div style={{ width: '1.25rem', height: '1.25rem', borderRadius: '9999px', background: 'white', position: 'absolute', top: '0.25rem', left: settings[key] ? '1.5rem' : '0.25rem', transition: 'left 0.2s' }} />
                    </button>
                  </div>
                ))}
                
                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.75rem', marginTop: '1.5rem' }}>
                  <button onClick={() => setShowSettings(false)} style={{ padding: '0.75rem 1.5rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1rem', fontWeight: '600' }}>Done</button>
                </div>
              </div>
            </div>
          )}

          {/* QR/Sync Modal */}
          {showQR && (
            <div onClick={() => setShowQR(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '28rem', maxHeight: '90vh', overflowY: 'auto' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '0.5rem' }}>Sync Displays</h2>
                
                {!roomCode ? (
                  <div style={{ marginTop: '1rem' }}>
                    <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1rem' }}>Create a sync room to connect multiple displays in real-time.</p>
                    <button onClick={createRoom} style={{ width: '100%', padding: '1rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1.125rem', fontWeight: '600' }}>Create Sync Room</button>
                  </div>
                ) : (
                  <>
                    <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1rem' }}>{isHost ? 'Scan QR or share the room code.' : 'Connected to this room.'}</p>
                    <div style={{ background: 'rgba(255,255,255,0.1)', borderRadius: '0.75rem', padding: '1rem', marginBottom: '1rem', textAlign: 'center' }}>
                      <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem' }}>Room Code</div>
                      <div style={{ color: 'white', fontSize: '2rem', fontFamily: 'monospace', fontWeight: 'bold', letterSpacing: '0.2em' }}>{roomCode}</div>
                      <div style={{ color: connected ? '#34d399' : '#f87171', fontSize: '0.875rem', marginTop: '0.5rem', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                        <Icons.Sync /> {connected ? `Connected${peerCount > 0 ? ` â€¢ ${peerCount} display${peerCount > 1 ? 's' : ''}` : ''}` : 'Connecting...'}
                      </div>
                    </div>
                    {isHost && (
                      <>
                        <div style={{ background: 'white', padding: '1rem', borderRadius: '1rem', display: 'flex', justifyContent: 'center', marginBottom: '1rem' }}>
                          <QRCodeCanvas value={getSyncUrl()} size={200} />
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                          <input type="text" value={getSyncUrl()} readOnly style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '0.75rem', fontFamily: 'monospace' }} />
                          <button onClick={() => copyToClipboard(getSyncUrl())} style={{ padding: '0.75rem', background: '#059669', border: 'none', borderRadius: '0.5rem' }}>
                            {copied ? <Icons.Check /> : <Icons.Copy />}
                          </button>
                        </div>
                      </>
                    )}
                  </>
                )}
                <div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowQR(false)} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>Close</button>
                </div>
              </div>
            </div>
          )}

          {/* Join Room Modal */}
          {showJoinModal && (
            <div onClick={() => setShowJoinModal(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '24rem' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '0.5rem' }}>Join Room</h2>
                <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1.5rem' }}>Enter the 6-character room code</p>
                <input type="text" value={joinRoomInput} onChange={(e) => setJoinRoomInput(e.target.value.toUpperCase().slice(0, 6))}
                  placeholder="ABCDEF" maxLength={6}
                  style={{ width: '100%', background: '#334155', border: 'none', borderRadius: '0.75rem', padding: '1rem', color: 'white', fontFamily: 'monospace', fontSize: '1.5rem', textAlign: 'center', letterSpacing: '0.2em' }}
                  autoFocus />
                <div style={{ marginTop: '1.5rem', display: 'flex', gap: '0.75rem', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowJoinModal(false)} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>Cancel</button>
                  <button onClick={joinRoom} disabled={joinRoomInput.length !== 6} style={{ padding: '0.75rem 1.5rem', background: joinRoomInput.length === 6 ? '#059669' : 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600', opacity: joinRoomInput.length === 6 ? 1 : 0.5 }}>Join</button>
                </div>
              </div>
            </div>
          )}

          {/* Keyboard Shortcuts Modal */}
          {showShortcuts && (
            <div onClick={() => setShowShortcuts(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '28rem' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '1.5rem' }}>âŒ¨ï¸ Keyboard Shortcuts</h2>
                <div style={{ display: 'grid', gap: '0.75rem' }}>
                  {[
                    ['Space', 'Start / Pause'],
                    ['S', 'Skip to next phase'],
                    ['R', 'Reset timer'],
                    ['M', 'Toggle sound'],
                    ['F', 'Toggle fullscreen'],
                    ['N', 'Next climber'],
                    ['A', 'Add attempt (+1)'],
                    ['T', 'Add top (+1)'],
                    ['â†‘', 'Add 5 seconds'],
                    ['â†“', 'Subtract 5 seconds'],
                    ['?', 'Show shortcuts'],
                    ['Esc', 'Close modals'],
                  ].map(([key, desc]) => (
                    <div key={key} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <span style={{ color: 'rgba(255,255,255,0.8)' }}>{desc}</span>
                      <span className="kbd">{key}</span>
                    </div>
                  ))}
                </div>
                <div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowShortcuts(false)} style={{ padding: '0.75rem 1.5rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>Got it!</button>
                </div>
              </div>
            </div>
          )}

          {/* Footer */}
          <div style={{ position: 'absolute', bottom: '0.75rem', color: 'rgba(255,255,255,0.25)', fontSize: '0.75rem', fontWeight: '500', display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <span>Three Rivers Rumble â€¢ Competition Timer</span>
            {isLocked && <span style={{ color: 'rgba(34,197,94,0.5)' }}>ðŸ”’ Screen lock active</span>}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<ClimbingTimer />);
  </script>
</body>
</html>

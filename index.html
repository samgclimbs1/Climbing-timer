<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Three Rivers Rumble - Competition Timer</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
    .tabular-nums { font-variant-numeric: tabular-nums; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    input[type="range"] { -webkit-appearance: none; background: rgba(255,255,255,0.2); border-radius: 9999px; height: 8px; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: white; cursor: pointer; }
    input[type="text"] { outline: none; }
    button { cursor: pointer; transition: transform 0.15s; }
    button:hover { transform: scale(1.02); }
    button:active { transform: scale(0.98); }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // QR Code Generator
    function generateQRCode(text) {
      const size = 29;
      const matrix = Array(size).fill(null).map(() => Array(size).fill(null));
      const reserved = Array(size).fill(null).map(() => Array(size).fill(false));
      
      function addFinderPattern(x, y) {
        for (let dy = -1; dy <= 7; dy++) {
          for (let dx = -1; dx <= 7; dx++) {
            const px = x + dx, py = y + dy;
            if (px < 0 || py < 0 || px >= size || py >= size) continue;
            reserved[py][px] = true;
            if (dx === -1 || dx === 7 || dy === -1 || dy === 7) matrix[py][px] = false;
            else if ((dx === 0 || dx === 6) || (dy === 0 || dy === 6)) matrix[py][px] = true;
            else if (dx >= 2 && dx <= 4 && dy >= 2 && dy <= 4) matrix[py][px] = true;
            else matrix[py][px] = false;
          }
        }
      }
      
      addFinderPattern(0, 0);
      addFinderPattern(size - 7, 0);
      addFinderPattern(0, size - 7);
      
      for (let i = 8; i < size - 8; i++) {
        reserved[6][i] = reserved[i][6] = true;
        matrix[6][i] = matrix[i][6] = i % 2 === 0;
      }
      
      reserved[size - 8][8] = true;
      matrix[size - 8][8] = true;
      
      for (let i = 0; i < 9; i++) { reserved[8][i] = reserved[i][8] = true; }
      for (let i = 0; i < 8; i++) { reserved[8][size - 1 - i] = reserved[size - 1 - i][8] = true; }
      
      const bytes = new TextEncoder().encode(text);
      let bits = '0100' + bytes.length.toString(2).padStart(8, '0');
      bytes.forEach(b => bits += b.toString(2).padStart(8, '0'));
      bits += '0000';
      while (bits.length % 8 !== 0) bits += '0';
      const capacity = 70 * 8;
      let padIndex = 0;
      const padBytes = ['11101100', '00010001'];
      while (bits.length < capacity) { bits += padBytes[padIndex++ % 2]; }
      
      let bitIndex = 0, upward = true;
      for (let col = size - 1; col >= 1; col -= 2) {
        if (col === 6) col = 5;
        for (let row = 0; row < size; row++) {
          const actualRow = upward ? size - 1 - row : row;
          for (let c = 0; c < 2; c++) {
            const x = col - c, y = actualRow;
            if (!reserved[y][x] && bitIndex < bits.length) matrix[y][x] = bits[bitIndex++] === '1';
          }
        }
        upward = !upward;
      }
      
      const formatBits = '111011111000100';
      for (let i = 0; i < 6; i++) { matrix[8][i] = formatBits[i] === '1'; matrix[i][8] = formatBits[14 - i] === '1'; }
      matrix[8][7] = formatBits[6] === '1'; matrix[8][8] = formatBits[7] === '1'; matrix[7][8] = formatBits[8] === '1';
      for (let i = 0; i < 7; i++) { matrix[8][size - 1 - i] = formatBits[14 - i] === '1'; matrix[size - 1 - i][8] = formatBits[i] === '1'; }
      matrix[8][size - 8] = formatBits[7] === '1';
      
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!reserved[y][x] && (x + y) % 2 === 0) matrix[y][x] = !matrix[y][x];
        }
      }
      return matrix;
    }

    const QRCodeCanvas = ({ value, size = 250 }) => {
      const canvasRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current || !value) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const qr = generateQRCode(value);
        const cellSize = size / qr.length;
        canvas.width = size; canvas.height = size;
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = '#000000';
        qr.forEach((row, y) => row.forEach((cell, x) => {
          if (cell) ctx.fillRect(Math.floor(x * cellSize), Math.floor(y * cellSize), Math.ceil(cellSize), Math.ceil(cellSize));
        }));
      }, [value, size]);
      return <canvas ref={canvasRef} style={{ width: size, height: size }} />;
    };

    // Audio
    const useAudio = () => {
      const audioContextRef = useRef(null);
      const getAudioContext = useCallback(() => {
        if (!audioContextRef.current || audioContextRef.current.state === 'closed')
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContextRef.current.state === 'suspended') audioContextRef.current.resume();
        return audioContextRef.current;
      }, []);
      
      const playBeep = useCallback((frequency = 880, duration = 0.15, type = 'sine', volume = 0.5) => {
        try {
          const ctx = getAudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain); gain.connect(ctx.destination);
          osc.frequency.value = frequency; osc.type = type;
          gain.gain.setValueAtTime(volume, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + duration);
        } catch (e) {}
      }, [getAudioContext]);
      
      return {
        // Short beep for countdown (3, 2, 1) - high pitched
        playCountdownBeep: useCallback(() => playBeep(1000, 0.15, 'sine', 0.6), [playBeep]),
        // Longer beep at 0 (end of phase) - same pitch but longer
        playEndBeep: useCallback(() => playBeep(1000, 0.6, 'sine', 0.6), [playBeep]),
        // One minute warning - double beep
        playOneMinuteBeep: useCallback(() => { playBeep(880, 0.15); setTimeout(() => playBeep(880, 0.15), 200); }, [playBeep]),
        // Alert for prep phase start
        playAlertBeep: useCallback(() => playBeep(550, 0.3, 'sine', 0.5), [playBeep]),
        getAudioContext
      };
    };

    // Icons
    const Icons = {
      Play: () => <svg width="32" height="32" viewBox="0 0 24 24" fill="white" stroke="white" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
      Pause: () => <svg width="32" height="32" viewBox="0 0 24 24" fill="white" stroke="white" strokeWidth="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
      Reset: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
      Skip: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg>,
      Settings: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>,
      QR: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="3" height="3"/><rect x="18" y="14" width="3" height="3"/><rect x="14" y="18" width="3" height="3"/><rect x="18" y="18" width="3" height="3"/></svg>,
      Volume: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>,
      Mute: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.5)" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>,
      Fullscreen: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>,
      Sync: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>,
      Users: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
      Check: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
      Copy: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Link: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
    };

    function ClimbingTimer() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlRoomCode = urlParams.get('room');
      const isDisplayMode = urlParams.get('display') === '1';
      
      const [roomCode, setRoomCode] = useState(urlRoomCode || '');
      const [isHost, setIsHost] = useState(!urlRoomCode);
      const [joinRoomInput, setJoinRoomInput] = useState('');
      
      const [settings, setSettings] = useState({
        climbDuration: 240,
        transitionDuration: 30,
        prepDuration: 0,
        warningTime: 60,
        enableAutoTransition: true,
      });
      
      const [timerState, setTimerState] = useState({
        isRunning: false,
        phase: 'idle',
        timeRemaining: 240,
        round: 1,
        phaseStartTime: null,
      });
      
      const [climberInfo, setClimberInfo] = useState({ name: '', number: '' });
      const [showSettings, setShowSettings] = useState(false);
      const [showQR, setShowQR] = useState(false);
      const [showJoinModal, setShowJoinModal] = useState(false);
      const [soundEnabled, setSoundEnabled] = useState(!isDisplayMode);
      const [copied, setCopied] = useState(false);
      const [connected, setConnected] = useState(false);
      const [peerCount, setPeerCount] = useState(0);
      const [peerError, setPeerError] = useState(null);
      
      const containerRef = useRef(null);
      const lastSecondRef = useRef(null);
      const phaseRef = useRef(timerState.phase);
      const peerRef = useRef(null);
      const connectionsRef = useRef([]);
      const timerStateRef = useRef(timerState);
      const settingsRef = useRef(settings);
      const climberInfoRef = useRef(climberInfo);
      
      useEffect(() => { timerStateRef.current = timerState; }, [timerState]);
      useEffect(() => { settingsRef.current = settings; }, [settings]);
      useEffect(() => { climberInfoRef.current = climberInfo; }, [climberInfo]);
      useEffect(() => { phaseRef.current = timerState.phase; }, [timerState.phase]);
      
      const { playOneMinuteBeep, playCountdownBeep, playEndBeep, playAlertBeep, getAudioContext } = useAudio();
      
      const broadcastState = useCallback(() => {
        const data = { type: 'state', timerState: timerStateRef.current, settings: settingsRef.current, climberInfo: climberInfoRef.current };
        connectionsRef.current.forEach(conn => {
          if (conn?.open) try { conn.send(data); } catch (e) {}
        });
      }, []);
      
      const handleReceivedState = useCallback((data) => {
        if (data.type === 'state') {
          setTimerState(data.timerState);
          setSettings(data.settings);
          setClimberInfo(data.climberInfo || { name: '', number: '' });
        }
      }, []);
      
      // PeerJS setup
      useEffect(() => {
        if (!roomCode) return;
        
        const peerId = isHost ? `trr-${roomCode}` : `trr-${roomCode}-${Date.now()}`;
        const peer = new Peer(peerId, { debug: 1 });
        peerRef.current = peer;
        
        peer.on('open', () => {
          setConnected(true);
          setPeerError(null);
          
          if (!isHost) {
            const conn = peer.connect(`trr-${roomCode}`, { reliable: true });
            conn.on('open', () => {
              connectionsRef.current = [conn];
              setPeerCount(1);
              conn.send({ type: 'requestState' });
            });
            conn.on('data', handleReceivedState);
            conn.on('close', () => { setPeerCount(0); setPeerError('Disconnected'); });
          }
        });
        
        if (isHost) {
          peer.on('connection', (conn) => {
            conn.on('open', () => {
              connectionsRef.current.push(conn);
              setPeerCount(connectionsRef.current.length);
              // Send initial state immediately
              conn.send({ type: 'state', timerState: timerStateRef.current, settings: settingsRef.current, climberInfo: climberInfoRef.current });
            });
            conn.on('data', (data) => {
              if (data.type === 'requestState') {
                conn.send({ type: 'state', timerState: timerStateRef.current, settings: settingsRef.current, climberInfo: climberInfoRef.current });
              }
            });
            conn.on('close', () => {
              connectionsRef.current = connectionsRef.current.filter(c => c !== conn);
              setPeerCount(connectionsRef.current.length);
            });
          });
        }
        
        peer.on('error', (err) => {
          if (err.type === 'unavailable-id') setPeerError('Room exists');
          else if (err.type === 'peer-unavailable') setPeerError('Room not found');
          else setPeerError('Connection error');
        });
        
        return () => {
          connectionsRef.current.forEach(c => { try { c.close(); } catch(e) {} });
          connectionsRef.current = [];
          peer?.destroy();
        };
      }, [roomCode, isHost, handleReceivedState]);
      
      // Broadcast on state change
      useEffect(() => {
        if (isHost && connected && roomCode) broadcastState();
      }, [timerState, settings, climberInfo, isHost, connected, roomCode, broadcastState]);
      
      // Continuous sync while running
      useEffect(() => {
        if (!isHost || !connected || !timerState.isRunning) return;
        const interval = setInterval(broadcastState, 250);
        return () => clearInterval(interval);
      }, [isHost, connected, timerState.isRunning, broadcastState]);
      
      const formatTime = (seconds) => `${Math.floor(Math.abs(seconds) / 60)}:${(Math.abs(seconds) % 60).toString().padStart(2, '0')}`;
      
      const getPhaseDuration = (phase) => {
        if (phase === 'prep') return settings.prepDuration;
        if (phase === 'climb') return settings.climbDuration;
        if (phase === 'transition') return settings.transitionDuration;
        return settings.climbDuration;
      };
      
      // Timer loop
      useEffect(() => {
        if (!timerState.isRunning || !timerState.phaseStartTime) return;
        
        const interval = setInterval(() => {
          const now = Date.now();
          const duration = getPhaseDuration(timerState.phase);
          const elapsed = Math.floor((now - timerState.phaseStartTime) / 1000);
          const remaining = Math.max(0, duration - elapsed);
          
          // Always update timeRemaining locally for smooth display
          setTimerState(prev => ({ ...prev, timeRemaining: remaining }));
          
          // Play sounds on all devices (host and clients)
          // USA Climbing pattern: beep at 3, 2, 1 seconds, longer beep at 0
          if (soundEnabled && remaining !== lastSecondRef.current && lastSecondRef.current !== null) {
            const prev = lastSecondRef.current;
            if (phaseRef.current === 'prep') {
              // Countdown beeps at 3, 2, 1
              if (remaining <= 3 && remaining > 0 && prev > remaining) playCountdownBeep();
              // Longer beep at 0 (climb starts)
              if (remaining === 0 && prev > 0) playEndBeep();
            } else if (phaseRef.current === 'climb') {
              // One minute warning
              if (remaining === settings.warningTime && prev > settings.warningTime) playOneMinuteBeep();
              // Countdown beeps at 3, 2, 1
              if (remaining <= 3 && remaining > 0 && prev > remaining) playCountdownBeep();
              // Longer beep at 0 (climb ends)
              if (remaining === 0 && prev > 0) playEndBeep();
            } else if (phaseRef.current === 'transition') {
              // Countdown beeps at 3, 2, 1
              if (remaining <= 3 && remaining > 0 && prev > remaining) playCountdownBeep();
              // Longer beep at 0 (next phase starts)
              if (remaining === 0 && prev > 0) playEndBeep();
            }
          }
          lastSecondRef.current = remaining;
          
          // Only host handles phase transitions
          if ((isHost || !roomCode) && remaining === 0 && elapsed >= duration && settings.enableAutoTransition) {
            const t = timerState.phaseStartTime + duration * 1000;
            setTimerState(prev => {
              if (prev.phase === 'prep') return { ...prev, phase: 'climb', phaseStartTime: t, timeRemaining: settings.climbDuration };
              if (prev.phase === 'climb') {
                if (settings.transitionDuration === 0) {
                  const np = settings.prepDuration > 0 ? 'prep' : 'climb';
                  return { ...prev, round: prev.round + 1, phase: np, phaseStartTime: t, timeRemaining: settings.prepDuration || settings.climbDuration };
                }
                return { ...prev, phase: 'transition', phaseStartTime: t, timeRemaining: settings.transitionDuration };
              }
              if (prev.phase === 'transition') {
                const np = settings.prepDuration > 0 ? 'prep' : 'climb';
                return { ...prev, phase: np, round: prev.round + 1, phaseStartTime: t, timeRemaining: settings.prepDuration || settings.climbDuration };
              }
              return prev;
            });
          }
        }, 50);
        return () => clearInterval(interval);
      }, [timerState.isRunning, timerState.phaseStartTime, timerState.phase, settings, soundEnabled, isHost, roomCode]);
      
      const handleStart = () => {
        getAudioContext();
        const now = Date.now();
        const startPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
        const startDuration = settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration;
        setTimerState(prev => ({
          ...prev, isRunning: true,
          phase: prev.phase === 'idle' ? startPhase : prev.phase,
          phaseStartTime: now,
          timeRemaining: prev.phase === 'idle' ? startDuration : prev.timeRemaining,
        }));
        if (soundEnabled && timerState.phase === 'idle') settings.prepDuration > 0 ? playAlertBeep() : playEndBeep();
      };
      
      const handlePause = () => setTimerState(prev => ({ ...prev, isRunning: false }));
      
      const handleReset = () => {
        setTimerState({ isRunning: false, phase: 'idle', timeRemaining: settings.climbDuration, round: 1, phaseStartTime: null });
        lastSecondRef.current = null;
      };
      
      const handleSkip = () => {
        const now = Date.now();
        setTimerState(prev => {
          if (prev.phase === 'prep') return { ...prev, phase: 'climb', phaseStartTime: now, timeRemaining: settings.climbDuration };
          if (prev.phase === 'climb') {
            if (settings.transitionDuration === 0) {
              const np = settings.prepDuration > 0 ? 'prep' : 'climb';
              return { ...prev, round: prev.round + 1, phase: np, phaseStartTime: now, timeRemaining: settings.prepDuration || settings.climbDuration };
            }
            return { ...prev, phase: 'transition', phaseStartTime: now, timeRemaining: settings.transitionDuration };
          }
          const np = settings.prepDuration > 0 ? 'prep' : 'climb';
          return { ...prev, phase: np, round: prev.round + 1, phaseStartTime: now, timeRemaining: settings.prepDuration || settings.climbDuration };
        });
      };
      
      const handleAddTime = (s) => setTimerState(prev => ({
        ...prev,
        phaseStartTime: prev.phaseStartTime ? prev.phaseStartTime + s * 1000 : prev.phaseStartTime,
        timeRemaining: Math.max(0, prev.timeRemaining + s),
      }));
      
      const toggleFullscreen = () => {
        if (!document.fullscreenElement) containerRef.current?.requestFullscreen();
        else document.exitFullscreen();
      };
      
      const createRoom = () => { setRoomCode(Math.random().toString(36).substring(2, 8).toUpperCase()); setIsHost(true); };
      const joinRoom = () => { if (joinRoomInput.trim()) { setRoomCode(joinRoomInput.trim().toUpperCase()); setIsHost(false); setShowJoinModal(false); } };
      const copyToClipboard = (t) => { navigator.clipboard.writeText(t); setCopied(true); setTimeout(() => setCopied(false), 2000); };
      const getSyncUrl = () => `${window.location.origin}${window.location.pathname}?room=${roomCode}`;
      
      const getPhaseColor = () => {
        if (timerState.phase === 'prep') return 'linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%)';
        if (timerState.phase === 'climb') return 'linear-gradient(135deg, #059669 0%, #064e3b 100%)';
        if (timerState.phase === 'transition') return 'linear-gradient(135deg, #f59e0b 0%, #c2410c 100%)';
        return 'linear-gradient(135deg, #334155 0%, #0f172a 100%)';
      };
      
      const getTimeColor = () => {
        if (timerState.timeRemaining <= 5 && timerState.timeRemaining > 0) return '#f87171';
        if (timerState.timeRemaining <= settings.warningTime && timerState.phase === 'climb') return '#fde047';
        return 'white';
      };
      
      const getPhaseLabel = () => {
        if (timerState.phase === 'prep') return '‚è≥ PREPARATION';
        if (timerState.phase === 'climb') return 'üßó CLIMB';
        if (timerState.phase === 'transition') return 'üîÑ TRANSITION';
        return 'READY';
      };
      
      const canControl = isHost || !roomCode;
      const progressPct = timerState.phase !== 'idle' ? ((getPhaseDuration(timerState.phase) - timerState.timeRemaining) / getPhaseDuration(timerState.phase)) * 100 : 0;

      return (
        <div ref={containerRef} style={{ minHeight: '100vh', background: getPhaseColor(), display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '1rem', transition: 'background 0.7s', position: 'relative' }}>
          
          {timerState.phase !== 'idle' && (
            <div style={{ position: 'absolute', top: 0, left: 0, right: 0, height: '6px', background: 'rgba(0,0,0,0.3)' }}>
              <div style={{ height: '100%', background: 'rgba(255,255,255,0.8)', width: `${progressPct}%`, transition: 'width 0.1s' }} />
            </div>
          )}
          
          <div style={{ position: 'absolute', top: '1rem', left: '1rem', right: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
              <span style={{ color: 'rgba(255,255,255,0.9)', fontSize: '1.5rem', fontWeight: 'bold' }}>Round {timerState.round}</span>
              {climberInfo.name && <span style={{ color: 'rgba(255,255,255,0.7)', fontSize: '1rem' }}>{climberInfo.number && `#${climberInfo.number} `}{climberInfo.name}</span>}
              {roomCode && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flexWrap: 'wrap' }}>
                  <span style={{ padding: '0.25rem 0.5rem', background: connected ? 'rgba(34,197,94,0.3)' : 'rgba(239,68,68,0.3)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                    <Icons.Sync /> {connected ? (isHost ? 'Hosting' : 'Synced') : 'Connecting...'}
                  </span>
                  {isHost && peerCount > 0 && <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}><Icons.Users /> {peerCount}</span>}
                  <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', fontFamily: 'monospace' }}>{roomCode}</span>
                </div>
              )}
              {peerError && <span style={{ color: '#f87171', fontSize: '0.75rem' }}>{peerError}</span>}
            </div>
            
            {canControl ? (
              <div style={{ display: 'flex', gap: '0.5rem' }}>
                <button onClick={() => { getAudioContext(); setSoundEnabled(!soundEnabled); }} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>{soundEnabled ? <Icons.Volume /> : <Icons.Mute />}</button>
                <button onClick={toggleFullscreen} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}><Icons.Fullscreen /></button>
                <button onClick={() => setShowSettings(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}><Icons.Settings /></button>
                <button onClick={() => setShowQR(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}><Icons.QR /></button>
              </div>
            ) : (
              <div style={{ display: 'flex', gap: '0.5rem' }}>
                <button onClick={() => { getAudioContext(); setSoundEnabled(!soundEnabled); }} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>{soundEnabled ? <Icons.Volume /> : <Icons.Mute />}</button>
                <button onClick={toggleFullscreen} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}><Icons.Fullscreen /></button>
              </div>
            )}
          </div>

          <div style={{ fontSize: 'clamp(1.5rem, 5vw, 2.5rem)', fontWeight: 'bold', textTransform: 'uppercase', letterSpacing: '0.1em', marginBottom: '0.5rem', color: 'rgba(255,255,255,0.95)' }}>{getPhaseLabel()}</div>

          <div className="tabular-nums" style={{ fontSize: 'clamp(6rem, 28vw, 16rem)', fontFamily: 'ui-monospace, monospace', fontWeight: 'bold', color: getTimeColor(), lineHeight: 1, animation: timerState.timeRemaining <= 5 && timerState.timeRemaining > 0 && timerState.phase !== 'idle' ? 'pulse 1s infinite' : 'none' }}>
            {formatTime(timerState.timeRemaining)}
          </div>

          <div style={{ marginTop: '0.5rem', color: 'rgba(255,255,255,0.6)', fontSize: '1.125rem', textAlign: 'center' }}>
            {timerState.phase === 'idle' && `${settings.prepDuration > 0 ? formatTime(settings.prepDuration) + ' prep ‚Ä¢ ' : ''}${formatTime(settings.climbDuration)} climb${settings.transitionDuration > 0 ? ' ‚Ä¢ ' + formatTime(settings.transitionDuration) + ' transition' : ''}`}
            {timerState.phase === 'prep' && 'Climber may inspect the wall'}
            {timerState.phase === 'climb' && (settings.transitionDuration > 0 ? 'Transition begins when timer ends' : 'Next round begins when timer ends')}
            {timerState.phase === 'transition' && `Round ${timerState.round + 1} starts when timer ends`}
          </div>

          {canControl && (
            <div style={{ marginTop: '2rem', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1rem' }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '0.75rem' }}>
                {!timerState.isRunning ? (
                  <button onClick={handleStart} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Play /> {timerState.phase === 'idle' ? 'Start' : 'Resume'}
                  </button>
                ) : (
                  <button onClick={handlePause} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Pause /> Pause
                  </button>
                )}
                {timerState.phase !== 'idle' && (
                  <>
                    <button onClick={handleSkip} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}><Icons.Skip /> Skip</button>
                    <button onClick={handleReset} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}><Icons.Reset /> Reset</button>
                  </>
                )}
              </div>
              {timerState.phase !== 'idle' && (
                <div style={{ display: 'flex', gap: '0.5rem' }}>
                  {[-10, -5, 5, 10].map(s => (
                    <button key={s} onClick={() => handleAddTime(s)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>{s > 0 ? '+' : ''}{s}s</button>
                  ))}
                </div>
              )}
            </div>
          )}

          {!roomCode && timerState.phase === 'idle' && (
            <div style={{ marginTop: '2rem', display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
              <button onClick={createRoom} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'white', fontSize: '0.875rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}><Icons.Link /> Create Sync Room</button>
              <button onClick={() => setShowJoinModal(true)} style={{ padding: '0.75rem 1.5rem', background: 'transparent', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'rgba(255,255,255,0.8)', fontSize: '0.875rem' }}>Join Existing Room</button>
            </div>
          )}

          {/* Settings Modal */}
          {showSettings && (
            <div onClick={() => setShowSettings(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '32rem', maxHeight: '90vh', overflowY: 'auto' }}>
                <h2 style={{ fontSize: '1.75rem', fontWeight: 'bold', color: 'white', marginBottom: '1.5rem' }}>Settings</h2>
                
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(255,255,255,0.05)', borderRadius: '0.75rem' }}>
                  <h3 style={{ color: 'rgba(255,255,255,0.8)', marginBottom: '0.75rem', fontSize: '1rem' }}>Climber Info</h3>
                  <div style={{ display: 'flex', gap: '0.75rem' }}>
                    <input type="text" placeholder="#" value={climberInfo.number} onChange={e => setClimberInfo(p => ({ ...p, number: e.target.value }))} style={{ width: '70px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                    <input type="text" placeholder="Name" value={climberInfo.name} onChange={e => setClimberInfo(p => ({ ...p, name: e.target.value }))} style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                  </div>
                </div>
                
                {[
                  { label: 'Preparation Time', key: 'prepDuration', min: 0, max: 120, step: 5, presets: [0, 30, 45, 60], color: '#7c3aed' },
                  { label: 'Climb Duration', key: 'climbDuration', min: 60, max: 600, step: 30, presets: [180, 240, 300, 360], color: '#059669' },
                  { label: 'Transition Duration', key: 'transitionDuration', min: 0, max: 120, step: 5, presets: [0, 15, 30, 45, 60], color: '#d97706' },
                ].map(({ label, key, min, max, step, presets, color }) => (
                  <div key={key} style={{ marginBottom: '1.5rem' }}>
                    <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>{label}</label>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                      <input type="range" min={min} max={max} step={step} value={settings[key]} onChange={e => setSettings(s => ({ ...s, [key]: parseInt(e.target.value) }))} style={{ flex: 1 }} />
                      <span style={{ color: 'white', fontFamily: 'monospace', fontSize: '1.25rem', width: '4rem', textAlign: 'right' }}>{settings[key] === 0 ? 'None' : formatTime(settings[key])}</span>
                    </div>
                    <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                      {presets.map(t => (
                        <button key={t} onClick={() => setSettings(s => ({ ...s, [key]: t }))} style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings[key] === t ? color : 'rgba(255,255,255,0.1)', color: settings[key] === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                          {t === 0 ? 'None' : formatTime(t)}
                        </button>
                      ))}
                    </div>
                  </div>
                ))}
                
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Warning Beep At</label>
                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                    {[30, 60, 90, 120].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, warningTime: t }))} style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.warningTime === t ? '#3b82f6' : 'rgba(255,255,255,0.1)', color: settings.warningTime === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                        {formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  <label style={{ color: 'rgba(255,255,255,0.8)' }}>Auto-advance phases</label>
                  <button onClick={() => setSettings(s => ({ ...s, enableAutoTransition: !s.enableAutoTransition }))} style={{ width: '3rem', height: '1.75rem', borderRadius: '9999px', border: 'none', background: settings.enableAutoTransition ? '#059669' : 'rgba(255,255,255,0.2)', position: 'relative' }}>
                    <div style={{ width: '1.25rem', height: '1.25rem', borderRadius: '9999px', background: 'white', position: 'absolute', top: '0.25rem', left: settings.enableAutoTransition ? '1.5rem' : '0.25rem', transition: 'left 0.2s' }} />
                  </button>
                </div>
                
                <button onClick={() => setShowSettings(false)} style={{ width: '100%', padding: '0.75rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1rem', fontWeight: '600' }}>Done</button>
              </div>
            </div>
          )}

          {/* QR Modal */}
          {showQR && (
            <div onClick={() => setShowQR(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '28rem' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '1rem' }}>Sync Displays</h2>
                
                {!roomCode ? (
                  <button onClick={createRoom} style={{ width: '100%', padding: '1rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1.125rem', fontWeight: '600' }}>Create Sync Room</button>
                ) : (
                  <>
                    <div style={{ background: 'rgba(255,255,255,0.1)', borderRadius: '0.75rem', padding: '1rem', marginBottom: '1rem', textAlign: 'center' }}>
                      <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem' }}>Room Code</div>
                      <div style={{ color: 'white', fontSize: '2rem', fontFamily: 'monospace', fontWeight: 'bold', letterSpacing: '0.2em' }}>{roomCode}</div>
                      <div style={{ color: connected ? '#34d399' : '#f87171', fontSize: '0.875rem', marginTop: '0.5rem' }}>
                        {connected ? `Connected${isHost && peerCount > 0 ? ` ‚Ä¢ ${peerCount} display${peerCount > 1 ? 's' : ''}` : ''}` : 'Connecting...'}
                      </div>
                    </div>
                    {isHost && (
                      <>
                        <div style={{ background: 'white', padding: '1rem', borderRadius: '1rem', display: 'flex', justifyContent: 'center', marginBottom: '1rem' }}>
                          <QRCodeCanvas value={getSyncUrl()} size={200} />
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                          <input type="text" value={getSyncUrl()} readOnly style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '0.7rem', fontFamily: 'monospace' }} />
                          <button onClick={() => copyToClipboard(getSyncUrl())} style={{ padding: '0.75rem', background: '#059669', border: 'none', borderRadius: '0.5rem' }}>{copied ? <Icons.Check /> : <Icons.Copy />}</button>
                        </div>
                      </>
                    )}
                    {peerError && <div style={{ marginTop: '1rem', padding: '0.75rem', background: 'rgba(239,68,68,0.2)', borderRadius: '0.5rem', color: '#f87171', fontSize: '0.875rem' }}>{peerError}</div>}
                  </>
                )}
                <button onClick={() => setShowQR(false)} style={{ width: '100%', marginTop: '1rem', padding: '0.75rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>Close</button>
              </div>
            </div>
          )}

          {/* Join Modal */}
          {showJoinModal && (
            <div onClick={() => setShowJoinModal(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '24rem' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '1.5rem' }}>Join Room</h2>
                <input type="text" value={joinRoomInput} onChange={e => setJoinRoomInput(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6))} placeholder="ABC123" maxLength={6} style={{ width: '100%', background: '#334155', border: 'none', borderRadius: '0.75rem', padding: '1rem', color: 'white', fontFamily: 'monospace', fontSize: '1.5rem', textAlign: 'center', letterSpacing: '0.2em' }} autoFocus />
                <div style={{ marginTop: '1.5rem', display: 'flex', gap: '0.75rem' }}>
                  <button onClick={() => setShowJoinModal(false)} style={{ flex: 1, padding: '0.75rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>Cancel</button>
                  <button onClick={joinRoom} disabled={joinRoomInput.length !== 6} style={{ flex: 1, padding: '0.75rem', background: joinRoomInput.length === 6 ? '#059669' : 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600', opacity: joinRoomInput.length === 6 ? 1 : 0.5 }}>Join</button>
                </div>
              </div>
            </div>
          )}

          <div style={{ position: 'absolute', bottom: '0.75rem', color: 'rgba(255,255,255,0.25)', fontSize: '0.75rem' }}>Three Rivers Rumble ‚Ä¢ Competition Timer</div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<ClimbingTimer />);
  </script>
</body>
</html>

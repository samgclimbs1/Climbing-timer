<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Three Rivers Rumble - Competition Timer</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
    .tabular-nums { font-variant-numeric: tabular-nums; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .animate-pulse { animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    input[type="range"] { -webkit-appearance: none; appearance: none; background: rgba(255,255,255,0.2); border-radius: 9999px; height: 8px; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: white; cursor: pointer; }
    input[type="text"], input[type="number"] { outline: none; }
    button { cursor: pointer; transition: all 0.15s; }
    button:hover { transform: scale(1.02); }
    button:active { transform: scale(0.98); }
    :fullscreen { background: inherit; }
    ::backdrop { background: black; }
    .progress-bar { transition: width 0.1s linear; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo } = React;

    // ============== QR CODE GENERATOR ==============
    function generateQRCode(text) {
      const size = 29;
      const matrix = Array(size).fill(null).map(() => Array(size).fill(null));
      const reserved = Array(size).fill(null).map(() => Array(size).fill(false));
      
      function addFinderPattern(x, y) {
        for (let dy = -1; dy <= 7; dy++) {
          for (let dx = -1; dx <= 7; dx++) {
            const px = x + dx, py = y + dy;
            if (px < 0 || py < 0 || px >= size || py >= size) continue;
            reserved[py][px] = true;
            if (dx === -1 || dx === 7 || dy === -1 || dy === 7) matrix[py][px] = false;
            else if ((dx === 0 || dx === 6) || (dy === 0 || dy === 6)) matrix[py][px] = true;
            else if (dx >= 2 && dx <= 4 && dy >= 2 && dy <= 4) matrix[py][px] = true;
            else matrix[py][px] = false;
          }
        }
      }
      
      addFinderPattern(0, 0);
      addFinderPattern(size - 7, 0);
      addFinderPattern(0, size - 7);
      
      for (let i = 8; i < size - 8; i++) {
        reserved[6][i] = reserved[i][6] = true;
        matrix[6][i] = matrix[i][6] = i % 2 === 0;
      }
      
      reserved[size - 8][8] = true;
      matrix[size - 8][8] = true;
      
      for (let i = 0; i < 9; i++) { reserved[8][i] = reserved[i][8] = true; }
      for (let i = 0; i < 8; i++) { reserved[8][size - 1 - i] = reserved[size - 1 - i][8] = true; }
      
      const bytes = new TextEncoder().encode(text);
      let bits = '0100' + bytes.length.toString(2).padStart(8, '0');
      bytes.forEach(b => bits += b.toString(2).padStart(8, '0'));
      bits += '0000';
      while (bits.length % 8 !== 0) bits += '0';
      const capacity = 70 * 8;
      let padIndex = 0;
      const padBytes = ['11101100', '00010001'];
      while (bits.length < capacity) { bits += padBytes[padIndex++ % 2]; }
      
      let bitIndex = 0, upward = true;
      for (let col = size - 1; col >= 1; col -= 2) {
        if (col === 6) col = 5;
        for (let row = 0; row < size; row++) {
          const actualRow = upward ? size - 1 - row : row;
          for (let c = 0; c < 2; c++) {
            const x = col - c, y = actualRow;
            if (!reserved[y][x] && bitIndex < bits.length) matrix[y][x] = bits[bitIndex++] === '1';
          }
        }
        upward = !upward;
      }
      
      const formatBits = '111011111000100';
      for (let i = 0; i < 6; i++) { matrix[8][i] = formatBits[i] === '1'; matrix[i][8] = formatBits[14 - i] === '1'; }
      matrix[8][7] = formatBits[6] === '1'; matrix[8][8] = formatBits[7] === '1'; matrix[7][8] = formatBits[8] === '1';
      for (let i = 0; i < 7; i++) { matrix[8][size - 1 - i] = formatBits[14 - i] === '1'; matrix[size - 1 - i][8] = formatBits[i] === '1'; }
      matrix[8][size - 8] = formatBits[7] === '1';
      
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!reserved[y][x] && (x + y) % 2 === 0) matrix[y][x] = !matrix[y][x];
        }
      }
      return matrix;
    }

    const QRCodeCanvas = ({ value, size = 250 }) => {
      const canvasRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current || !value) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const qr = generateQRCode(value);
        const cellSize = size / qr.length;
        canvas.width = size; canvas.height = size;
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = '#000000';
        qr.forEach((row, y) => row.forEach((cell, x) => {
          if (cell) ctx.fillRect(Math.floor(x * cellSize), Math.floor(y * cellSize), Math.ceil(cellSize), Math.ceil(cellSize));
        }));
      }, [value, size]);
      return <canvas ref={canvasRef} style={{ width: size, height: size }} />;
    };

    // ============== AUDIO HOOK ==============
    const useAudio = () => {
      const audioContextRef = useRef(null);
      const getAudioContext = useCallback(() => {
        if (!audioContextRef.current || audioContextRef.current.state === 'closed')
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContextRef.current.state === 'suspended') audioContextRef.current.resume();
        return audioContextRef.current;
      }, []);
      
      const playBeep = useCallback((frequency = 880, duration = 0.15, type = 'sine', volume = 0.5) => {
        try {
          const ctx = getAudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain); gain.connect(ctx.destination);
          osc.frequency.value = frequency; osc.type = type;
          gain.gain.setValueAtTime(volume, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + duration);
        } catch (e) { console.log('Audio error:', e); }
      }, [getAudioContext]);
      
      const playDoubleBeep = useCallback(() => {
        playBeep(880, 0.15, 'sine', 0.5);
        setTimeout(() => playBeep(880, 0.15, 'sine', 0.5), 200);
      }, [playBeep]);
      
      return {
        playStartBeep: useCallback(() => playBeep(1000, 0.6, 'sine', 0.6), [playBeep]),
        playOneMinuteBeep: useCallback(() => playDoubleBeep(), [playDoubleBeep]),
        playCountdownBeep: useCallback(() => playBeep(660, 0.15, 'sine', 0.5), [playBeep]),
        playEndBeep: useCallback(() => playBeep(440, 1.0, 'square', 0.4), [playBeep]),
        playAlertBeep: useCallback(() => playBeep(550, 0.3, 'sine', 0.5), [playBeep]),
        getAudioContext
      };
    };

    // ============== PEER SYNC HOOK ==============
    const usePeerSync = (roomCode, isHost, onStateReceived) => {
      const peerRef = useRef(null);
      const connectionsRef = useRef([]);
      const [connected, setConnected] = useState(false);
      const [peerCount, setPeerCount] = useState(0);
      const [error, setError] = useState(null);
      
      useEffect(() => {
        if (!roomCode) return;
        
        const peerId = isHost ? `trr-host-${roomCode}` : `trr-client-${roomCode}-${Date.now()}`;
        const peer = new Peer(peerId, { debug: 0 });
        peerRef.current = peer;
        
        peer.on('open', () => {
          setConnected(true);
          setError(null);
          
          if (!isHost) {
            const conn = peer.connect(`trr-host-${roomCode}`, { reliable: true });
            conn.on('open', () => {
              connectionsRef.current = [conn];
              setPeerCount(1);
            });
            conn.on('data', (data) => {
              if (onStateReceived) onStateReceived(data);
            });
            conn.on('close', () => {
              setPeerCount(0);
              setError('Disconnected from host');
            });
            conn.on('error', (err) => setError('Connection error'));
          }
        });
        
        if (isHost) {
          peer.on('connection', (conn) => {
            conn.on('open', () => {
              connectionsRef.current.push(conn);
              setPeerCount(connectionsRef.current.length);
            });
            conn.on('close', () => {
              connectionsRef.current = connectionsRef.current.filter(c => c !== conn);
              setPeerCount(connectionsRef.current.length);
            });
          });
        }
        
        peer.on('error', (err) => {
          console.error('Peer error:', err);
          if (err.type === 'unavailable-id') {
            setError('Room already exists');
          } else if (err.type === 'peer-unavailable') {
            setError('Room not found');
          } else {
            setError('Connection error');
          }
        });
        
        return () => {
          connectionsRef.current.forEach(c => c.close());
          peer.destroy();
        };
      }, [roomCode, isHost]);
      
      const broadcast = useCallback((data) => {
        connectionsRef.current.forEach(conn => {
          if (conn.open) conn.send(data);
        });
      }, []);
      
      return { connected, peerCount, error, broadcast };
    };

    // ============== ICONS ==============
    const Icons = {
      Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="white" stroke="white" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
      Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="white" stroke="white" strokeWidth="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
      Reset: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
      Skip: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg>,
      Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>,
      QR: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><path d="M14 14h3v3h-3z"/><path d="M17 17h3v3h-3z"/><path d="M14 17h3v3h-3z"/><path d="M17 14h3v3h-3z"/></svg>,
      Volume: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>,
      Mute: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.5)" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>,
      Sync: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>,
      Fullscreen: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>,
      Users: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
      Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
      Copy: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Link: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
    };

    // ============== MAIN COMPONENT ==============
    function ClimbingTimer() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlRoomCode = urlParams.get('room');
      const isDisplayMode = urlParams.get('display') === '1';
      
      const generateRoomCode = () => Math.random().toString(36).substring(2, 8).toUpperCase();
      
      const [roomCode, setRoomCode] = useState(urlRoomCode || '');
      const [isHost, setIsHost] = useState(!urlRoomCode);
      const [joinRoomInput, setJoinRoomInput] = useState('');
      
      const [settings, setSettings] = useState({
        climbDuration: 240,
        transitionDuration: 30,
        prepDuration: 0,
        warningTime: 60,
        enableAutoTransition: true,
      });
      
      const [timerState, setTimerState] = useState({
        isRunning: false,
        phase: 'idle',
        timeRemaining: 240,
        round: 1,
        phaseStartTime: null,
      });
      
      const [climberInfo, setClimberInfo] = useState({ name: '', number: '' });
      const [showSettings, setShowSettings] = useState(false);
      const [showQR, setShowQR] = useState(false);
      const [showJoinModal, setShowJoinModal] = useState(false);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [copied, setCopied] = useState(false);
      const [isFullscreen, setIsFullscreen] = useState(false);
      
      const containerRef = useRef(null);
      const lastSecondRef = useRef(null);
      const phaseRef = useRef(timerState.phase);
      
      const { playStartBeep, playOneMinuteBeep, playCountdownBeep, playEndBeep, playAlertBeep, getAudioContext } = useAudio();
      
      const handleSyncState = useCallback((data) => {
        if (data.type === 'state') {
          setTimerState(data.timerState);
          setSettings(data.settings);
          setClimberInfo(data.climberInfo || { name: '', number: '' });
        }
      }, []);
      
      const { connected, peerCount, error, broadcast } = usePeerSync(
        roomCode, 
        isHost, 
        handleSyncState
      );
      
      useEffect(() => { phaseRef.current = timerState.phase; }, [timerState.phase]);
      
      useEffect(() => {
        if (isHost && connected && roomCode) {
          broadcast({ type: 'state', timerState, settings, climberInfo });
        }
      }, [timerState, settings, climberInfo, isHost, connected, broadcast, roomCode]);
      
      const formatTime = (seconds) => {
        const mins = Math.floor(Math.abs(seconds) / 60);
        const secs = Math.abs(seconds) % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };
      
      const getPhaseLabel = () => {
        switch (timerState.phase) {
          case 'prep': return 'â³ PREPARATION';
          case 'climb': return 'ðŸ§— CLIMB';
          case 'transition': return 'ðŸ”„ TRANSITION';
          default: return 'READY';
        }
      };
      
      const getPhaseDuration = (phase) => {
        switch (phase) {
          case 'prep': return settings.prepDuration;
          case 'climb': return settings.climbDuration;
          case 'transition': return settings.transitionDuration;
          default: return settings.climbDuration;
        }
      };
      
      useEffect(() => {
        if (!timerState.isRunning || !timerState.phaseStartTime) return;
        
        const interval = setInterval(() => {
          const now = Date.now();
          const duration = getPhaseDuration(timerState.phase);
          const elapsed = Math.floor((now - timerState.phaseStartTime) / 1000);
          const remaining = Math.max(0, duration - elapsed);
          
          setTimerState(prev => ({ ...prev, timeRemaining: remaining }));
          
          if (soundEnabled && (isHost || !roomCode) && remaining !== lastSecondRef.current && lastSecondRef.current !== null) {
            const prev = lastSecondRef.current;
            
            if (phaseRef.current === 'prep') {
              if (remaining <= 5 && remaining > 0 && prev > remaining) playCountdownBeep();
              if (remaining === 0 && prev > 0) playStartBeep();
            } else if (phaseRef.current === 'climb') {
              if (remaining === settings.warningTime && prev > settings.warningTime) playOneMinuteBeep();
              if (remaining <= 5 && remaining > 0 && prev > remaining) playCountdownBeep();
              if (remaining === 0 && prev > 0) playEndBeep();
            } else if (phaseRef.current === 'transition') {
              if (remaining <= 5 && remaining > 0 && prev > remaining) playCountdownBeep();
              if (remaining === 0 && prev > 0) {
                if (settings.prepDuration > 0) playAlertBeep();
                else playStartBeep();
              }
            }
          }
          lastSecondRef.current = remaining;
          
          if (remaining === 0 && elapsed >= duration && settings.enableAutoTransition) {
            const transitionTime = timerState.phaseStartTime + duration * 1000;
            
            setTimerState(prev => {
              if (prev.phase === 'prep') {
                return { ...prev, phase: 'climb', phaseStartTime: transitionTime, timeRemaining: settings.climbDuration };
              } else if (prev.phase === 'climb') {
                if (settings.transitionDuration === 0) {
                  return { ...prev, round: prev.round + 1, phaseStartTime: transitionTime, timeRemaining: settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration, phase: settings.prepDuration > 0 ? 'prep' : 'climb' };
                }
                return { ...prev, phase: 'transition', phaseStartTime: transitionTime, timeRemaining: settings.transitionDuration };
              } else if (prev.phase === 'transition') {
                const nextPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
                const nextDuration = settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration;
                return { ...prev, phase: nextPhase, round: prev.round + 1, phaseStartTime: transitionTime, timeRemaining: nextDuration };
              }
              return prev;
            });
          }
        }, 50);
        
        return () => clearInterval(interval);
      }, [timerState.isRunning, timerState.phaseStartTime, timerState.phase, settings, soundEnabled, isHost, roomCode]);
      
      const handleStart = () => {
        getAudioContext();
        const now = Date.now();
        const startPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
        const startDuration = settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration;
        
        setTimerState(prev => ({
          ...prev,
          isRunning: true,
          phase: prev.phase === 'idle' ? startPhase : prev.phase,
          phaseStartTime: now,
          timeRemaining: prev.phase === 'idle' ? startDuration : prev.timeRemaining,
        }));
        
        if (soundEnabled && timerState.phase === 'idle') {
          if (settings.prepDuration > 0) playAlertBeep();
          else playStartBeep();
        }
      };
      
      const handlePause = () => {
        setTimerState(prev => ({ ...prev, isRunning: false }));
      };
      
      const handleReset = () => {
        setTimerState({
          isRunning: false,
          phase: 'idle',
          timeRemaining: settings.climbDuration,
          round: 1,
          phaseStartTime: null,
        });
        lastSecondRef.current = null;
      };
      
      const handleSkip = () => {
        const now = Date.now();
        setTimerState(prev => {
          if (prev.phase === 'prep') {
            return { ...prev, phase: 'climb', phaseStartTime: now, timeRemaining: settings.climbDuration };
          } else if (prev.phase === 'climb') {
            if (settings.transitionDuration === 0) {
              const nextPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
              return { ...prev, round: prev.round + 1, phaseStartTime: now, timeRemaining: settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration, phase: nextPhase };
            }
            return { ...prev, phase: 'transition', phaseStartTime: now, timeRemaining: settings.transitionDuration };
          } else {
            const nextPhase = settings.prepDuration > 0 ? 'prep' : 'climb';
            return { ...prev, phase: nextPhase, round: prev.round + 1, phaseStartTime: now, timeRemaining: settings.prepDuration > 0 ? settings.prepDuration : settings.climbDuration };
          }
        });
      };
      
      const handleAddTime = (seconds) => {
        setTimerState(prev => ({
          ...prev,
          phaseStartTime: prev.phaseStartTime ? prev.phaseStartTime + (seconds * 1000) : prev.phaseStartTime,
          timeRemaining: prev.timeRemaining + seconds,
        }));
      };
      
      const toggleFullscreen = () => {
        if (!document.fullscreenElement) {
          containerRef.current?.requestFullscreen();
          setIsFullscreen(true);
        } else {
          document.exitFullscreen();
          setIsFullscreen(false);
        }
      };
      
      const createRoom = () => {
        const code = generateRoomCode();
        setRoomCode(code);
        setIsHost(true);
      };
      
      const joinRoom = () => {
        if (joinRoomInput.trim()) {
          setRoomCode(joinRoomInput.trim().toUpperCase());
          setIsHost(false);
          setShowJoinModal(false);
        }
      };
      
      const copyToClipboard = (text) => {
        navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      };
      
      const getSyncUrl = () => {
        return `${window.location.origin}${window.location.pathname}?room=${roomCode}&display=1`;
      };
      
      const getPhaseColor = () => {
        switch (timerState.phase) {
          case 'prep': return 'linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%)';
          case 'climb': return 'linear-gradient(135deg, #059669 0%, #064e3b 100%)';
          case 'transition': return 'linear-gradient(135deg, #f59e0b 0%, #c2410c 100%)';
          default: return 'linear-gradient(135deg, #334155 0%, #0f172a 100%)';
        }
      };
      
      const getTimeColor = () => {
        if (timerState.timeRemaining <= 5 && timerState.timeRemaining > 0) return '#f87171';
        if (timerState.timeRemaining <= settings.warningTime && timerState.phase === 'climb') return '#fde047';
        return 'white';
      };
      
      const getProgressPercent = () => {
        const duration = getPhaseDuration(timerState.phase);
        if (duration === 0) return 0;
        return ((duration - timerState.timeRemaining) / duration) * 100;
      };
      
      const canControl = isHost || !roomCode;

      return (
        <div ref={containerRef} style={{ minHeight: '100vh', background: getPhaseColor(), display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '1rem', transition: 'background 0.7s', position: 'relative' }}>
          
          {timerState.phase !== 'idle' && (
            <div style={{ position: 'absolute', top: 0, left: 0, right: 0, height: '6px', background: 'rgba(0,0,0,0.3)' }}>
              <div className="progress-bar" style={{ height: '100%', background: 'rgba(255,255,255,0.8)', width: `${getProgressPercent()}%` }} />
            </div>
          )}
          
          <div style={{ position: 'absolute', top: '1rem', left: '1rem', right: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
              <span style={{ color: 'rgba(255,255,255,0.9)', fontSize: '1.5rem', fontWeight: 'bold' }}>Round {timerState.round}</span>
              {climberInfo.name && (
                <span style={{ color: 'rgba(255,255,255,0.7)', fontSize: '1rem' }}>
                  {climberInfo.number && `#${climberInfo.number} `}{climberInfo.name}
                </span>
              )}
              {roomCode && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginTop: '0.25rem' }}>
                  <span style={{ padding: '0.25rem 0.5rem', background: connected ? 'rgba(34,197,94,0.3)' : 'rgba(239,68,68,0.3)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                    <Icons.Sync /> {connected ? 'Connected' : 'Connecting...'}
                  </span>
                  {isHost && peerCount > 0 && (
                    <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                      <Icons.Users /> {peerCount}
                    </span>
                  )}
                  <span style={{ padding: '0.25rem 0.5rem', background: 'rgba(255,255,255,0.2)', borderRadius: '0.25rem', color: 'white', fontSize: '0.75rem', fontFamily: 'monospace' }}>
                    {roomCode}
                  </span>
                </div>
              )}
            </div>
            
            {canControl && (
              <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', justifyContent: 'flex-end' }}>
                <button onClick={() => { getAudioContext(); setSoundEnabled(!soundEnabled); }} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                  {soundEnabled ? <Icons.Volume /> : <Icons.Mute />}
                </button>
                <button onClick={toggleFullscreen} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                  <Icons.Fullscreen />
                </button>
                <button onClick={() => setShowSettings(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                  <Icons.Settings />
                </button>
                <button onClick={() => setShowQR(true)} style={{ padding: '0.75rem', borderRadius: '9999px', background: 'rgba(255,255,255,0.1)', border: 'none' }}>
                  <Icons.QR />
                </button>
              </div>
            )}
          </div>

          <div style={{ fontSize: 'clamp(1.5rem, 5vw, 2.5rem)', fontWeight: 'bold', textTransform: 'uppercase', letterSpacing: '0.1em', marginBottom: '0.5rem', color: 'rgba(255,255,255,0.95)' }}>
            {getPhaseLabel()}
          </div>

          <div className="tabular-nums" style={{ fontSize: 'clamp(6rem, 28vw, 16rem)', fontFamily: 'ui-monospace, monospace', fontWeight: 'bold', color: getTimeColor(), lineHeight: 1, transition: 'color 0.3s', animation: timerState.timeRemaining <= 5 && timerState.timeRemaining > 0 && timerState.phase !== 'idle' ? 'pulse 1s infinite' : 'none' }}>
            {formatTime(timerState.timeRemaining)}
          </div>

          <div style={{ marginTop: '0.5rem', color: 'rgba(255,255,255,0.6)', fontSize: '1.125rem', textAlign: 'center' }}>
            {timerState.phase === 'idle' && (
              settings.prepDuration > 0 
                ? `${formatTime(settings.prepDuration)} prep â€¢ ${formatTime(settings.climbDuration)} climb${settings.transitionDuration > 0 ? ` â€¢ ${formatTime(settings.transitionDuration)} transition` : ''}`
                : `${formatTime(settings.climbDuration)} climb${settings.transitionDuration > 0 ? ` â€¢ ${formatTime(settings.transitionDuration)} transition` : ' â€¢ no transition'}`
            )}
            {timerState.phase === 'prep' && 'Climber may inspect the wall'}
            {timerState.phase === 'climb' && (settings.transitionDuration > 0 ? 'Transition begins when timer ends' : 'Next round begins when timer ends')}
            {timerState.phase === 'transition' && `Round ${timerState.round + 1} starts when timer ends`}
          </div>

          {canControl && (
            <div style={{ marginTop: '2rem', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1rem' }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '0.75rem' }}>
                {!timerState.isRunning ? (
                  <button onClick={handleStart} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Play /> {timerState.phase === 'idle' ? 'Start' : 'Resume'}
                  </button>
                ) : (
                  <button onClick={handlePause} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem 2.5rem', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.5rem', fontWeight: '600' }}>
                    <Icons.Pause /> Pause
                  </button>
                )}
                
                {timerState.phase !== 'idle' && (
                  <>
                    <button onClick={handleSkip} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}>
                      <Icons.Skip /> Skip
                    </button>
                    <button onClick={handleReset} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '1rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '1rem', color: 'white', fontSize: '1.25rem' }}>
                      <Icons.Reset /> Reset
                    </button>
                  </>
                )}
              </div>
              
              {timerState.phase !== 'idle' && (
                <div style={{ display: 'flex', gap: '0.5rem' }}>
                  <button onClick={() => handleAddTime(-10)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>-10s</button>
                  <button onClick={() => handleAddTime(-5)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>-5s</button>
                  <button onClick={() => handleAddTime(5)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>+5s</button>
                  <button onClick={() => handleAddTime(10)} style={{ padding: '0.5rem 1rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', color: 'white', fontSize: '0.875rem' }}>+10s</button>
                </div>
              )}
            </div>
          )}

          {!roomCode && timerState.phase === 'idle' && (
            <div style={{ marginTop: '2rem', display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
              <button onClick={createRoom} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'white', fontSize: '0.875rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <Icons.Link /> Create Sync Room
              </button>
              <button onClick={() => setShowJoinModal(true)} style={{ padding: '0.75rem 1.5rem', background: 'transparent', border: '1px solid rgba(255,255,255,0.3)', borderRadius: '0.75rem', color: 'rgba(255,255,255,0.8)', fontSize: '0.875rem' }}>
                Join Existing Room
              </button>
            </div>
          )}

          {showSettings && (
            <div onClick={() => setShowSettings(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '32rem', maxHeight: '90vh', overflowY: 'auto' }}>
                <h2 style={{ fontSize: '1.75rem', fontWeight: 'bold', color: 'white', marginBottom: '1.5rem' }}>Settings</h2>
                
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(255,255,255,0.05)', borderRadius: '0.75rem' }}>
                  <h3 style={{ color: 'rgba(255,255,255,0.8)', marginBottom: '0.75rem', fontSize: '1rem' }}>Climber Info (Optional)</h3>
                  <div style={{ display: 'flex', gap: '0.75rem' }}>
                    <input type="text" placeholder="Number" value={climberInfo.number} onChange={e => setClimberInfo(p => ({ ...p, number: e.target.value }))}
                      style={{ width: '80px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                    <input type="text" placeholder="Name" value={climberInfo.name} onChange={e => setClimberInfo(p => ({ ...p, name: e.target.value }))}
                      style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem' }} />
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Preparation Time</label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                    <input type="range" min="0" max="120" step="5" value={settings.prepDuration}
                      onChange={(e) => setSettings(s => ({ ...s, prepDuration: parseInt(e.target.value) }))}
                      style={{ flex: 1 }} />
                    <span style={{ color: 'white', fontFamily: 'monospace', fontSize: '1.25rem', width: '4rem', textAlign: 'right' }}>{settings.prepDuration === 0 ? 'None' : formatTime(settings.prepDuration)}</span>
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                    {[0, 30, 45, 60].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, prepDuration: t }))}
                        style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.prepDuration === t ? '#7c3aed' : 'rgba(255,255,255,0.1)', color: settings.prepDuration === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                        {t === 0 ? 'None' : formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Climb Duration</label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                    <input type="range" min="60" max="600" step="30" value={settings.climbDuration}
                      onChange={(e) => setSettings(s => ({ ...s, climbDuration: parseInt(e.target.value) }))}
                      style={{ flex: 1 }} />
                    <span style={{ color: 'white', fontFamily: 'monospace', fontSize: '1.25rem', width: '4rem', textAlign: 'right' }}>{formatTime(settings.climbDuration)}</span>
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                    {[180, 240, 300, 360, 480].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, climbDuration: t }))}
                        style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.climbDuration === t ? '#059669' : 'rgba(255,255,255,0.1)', color: settings.climbDuration === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                        {formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Transition Duration</label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                    <input type="range" min="0" max="120" step="5" value={settings.transitionDuration}
                      onChange={(e) => setSettings(s => ({ ...s, transitionDuration: parseInt(e.target.value) }))}
                      style={{ flex: 1 }} />
                    <span style={{ color: 'white', fontFamily: 'monospace', fontSize: '1.25rem', width: '4rem', textAlign: 'right' }}>{settings.transitionDuration === 0 ? 'None' : formatTime(settings.transitionDuration)}</span>
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                    {[0, 15, 30, 45, 60].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, transitionDuration: t }))}
                        style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.transitionDuration === t ? '#d97706' : 'rgba(255,255,255,0.1)', color: settings.transitionDuration === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                        {t === 0 ? 'None' : formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem' }}>
                  <label style={{ display: 'block', color: 'rgba(255,255,255,0.8)', marginBottom: '0.5rem' }}>Warning Beep At</label>
                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                    {[30, 60, 90, 120].map(t => (
                      <button key={t} onClick={() => setSettings(s => ({ ...s, warningTime: t }))}
                        style={{ padding: '0.4rem 0.8rem', borderRadius: '0.5rem', fontSize: '0.8rem', fontWeight: '500', border: 'none', background: settings.warningTime === t ? '#3b82f6' : 'rgba(255,255,255,0.1)', color: settings.warningTime === t ? 'white' : 'rgba(255,255,255,0.7)' }}>
                        {formatTime(t)}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '1.5rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  <label style={{ color: 'rgba(255,255,255,0.8)' }}>Auto-advance phases</label>
                  <button onClick={() => setSettings(s => ({ ...s, enableAutoTransition: !s.enableAutoTransition }))}
                    style={{ width: '3rem', height: '1.75rem', borderRadius: '9999px', border: 'none', background: settings.enableAutoTransition ? '#059669' : 'rgba(255,255,255,0.2)', position: 'relative', transition: 'background 0.2s' }}>
                    <div style={{ width: '1.25rem', height: '1.25rem', borderRadius: '9999px', background: 'white', position: 'absolute', top: '0.25rem', left: settings.enableAutoTransition ? '1.5rem' : '0.25rem', transition: 'left 0.2s' }} />
                  </button>
                </div>
                
                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.75rem' }}>
                  <button onClick={() => setShowSettings(false)}
                    style={{ padding: '0.75rem 1.5rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1rem', fontWeight: '600' }}>
                    Done
                  </button>
                </div>
              </div>
            </div>
          )}

          {showQR && (
            <div onClick={() => setShowQR(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '28rem', maxHeight: '90vh', overflowY: 'auto' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '0.5rem' }}>Sync Displays</h2>
                
                {!roomCode ? (
                  <div style={{ marginTop: '1rem' }}>
                    <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1rem' }}>Create a sync room to connect multiple displays in real-time.</p>
                    <button onClick={() => { createRoom(); }} style={{ width: '100%', padding: '1rem', background: '#059669', border: 'none', borderRadius: '0.75rem', color: 'white', fontSize: '1.125rem', fontWeight: '600' }}>
                      Create Sync Room
                    </button>
                  </div>
                ) : (
                  <>
                    <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1rem' }}>
                      {isHost ? 'Scan this QR code or share the room code with other displays.' : 'You are connected to this room.'}
                    </p>
                    
                    <div style={{ background: 'rgba(255,255,255,0.1)', borderRadius: '0.75rem', padding: '1rem', marginBottom: '1rem', textAlign: 'center' }}>
                      <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem', marginBottom: '0.25rem' }}>Room Code</div>
                      <div style={{ color: 'white', fontSize: '2rem', fontFamily: 'monospace', fontWeight: 'bold', letterSpacing: '0.2em' }}>{roomCode}</div>
                      <div style={{ color: connected ? '#34d399' : '#f87171', fontSize: '0.875rem', marginTop: '0.5rem', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                        <Icons.Sync /> {connected ? `Connected${peerCount > 0 ? ` â€¢ ${peerCount} display${peerCount > 1 ? 's' : ''}` : ''}` : 'Connecting...'}
                      </div>
                    </div>
                    
                    {isHost && (
                      <>
                        <div style={{ background: 'white', padding: '1rem', borderRadius: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'center', marginBottom: '1rem' }}>
                          <QRCodeCanvas value={getSyncUrl()} size={200} />
                        </div>
                        
                        <div>
                          <p style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.875rem', marginBottom: '0.5rem' }}>Or share this link:</p>
                          <div style={{ display: 'flex', gap: '0.5rem' }}>
                            <input type="text" value={getSyncUrl()} readOnly
                              style={{ flex: 1, background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '0.75rem', fontFamily: 'monospace' }} />
                            <button onClick={() => copyToClipboard(getSyncUrl())}
                              style={{ padding: '0.75rem', background: '#059669', border: 'none', borderRadius: '0.5rem' }}>
                              {copied ? <Icons.Check /> : <Icons.Copy />}
                            </button>
                          </div>
                        </div>
                      </>
                    )}
                    
                    {error && (
                      <div style={{ marginTop: '1rem', padding: '0.75rem', background: 'rgba(239,68,68,0.2)', borderRadius: '0.5rem', color: '#f87171', fontSize: '0.875rem' }}>
                        {error}
                      </div>
                    )}
                  </>
                )}
                
                <div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowQR(false)} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>
                    Close
                  </button>
                </div>
              </div>
            </div>
          )}

          {showJoinModal && (
            <div onClick={() => setShowJoinModal(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.7)', backdropFilter: 'blur(4px)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 50, padding: '1rem' }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#1e293b', borderRadius: '1.5rem', padding: '2rem', width: '100%', maxWidth: '24rem' }}>
                <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white', marginBottom: '0.5rem' }}>Join Room</h2>
                <p style={{ color: 'rgba(255,255,255,0.6)', marginBottom: '1.5rem' }}>Enter the 6-character room code</p>
                
                <input type="text" value={joinRoomInput} onChange={(e) => setJoinRoomInput(e.target.value.toUpperCase().slice(0, 6))}
                  placeholder="ABCDEF" maxLength={6}
                  style={{ width: '100%', background: '#334155', border: 'none', borderRadius: '0.75rem', padding: '1rem', color: 'white', fontFamily: 'monospace', fontSize: '1.5rem', textAlign: 'center', letterSpacing: '0.2em' }}
                  autoFocus />
                
                <div style={{ marginTop: '1.5rem', display: 'flex', gap: '0.75rem', justifyContent: 'flex-end' }}>
                  <button onClick={() => setShowJoinModal(false)} style={{ padding: '0.75rem 1.5rem', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600' }}>
                    Cancel
                  </button>
                  <button onClick={joinRoom} disabled={joinRoomInput.length !== 6} style={{ padding: '0.75rem 1.5rem', background: joinRoomInput.length === 6 ? '#059669' : 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '0.75rem', color: 'white', fontWeight: '600', opacity: joinRoomInput.length === 6 ? 1 : 0.5 }}>
                    Join
                  </button>
                </div>
              </div>
            </div>
          )}

          <div style={{ position: 'absolute', bottom: '0.75rem', color: 'rgba(255,255,255,0.25)', fontSize: '0.75rem', fontWeight: '500' }}>
            Three Rivers Rumble â€¢ Competition Timer
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<ClimbingTimer />);
  </script>
</body>
</html>
